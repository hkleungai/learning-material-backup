<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>COMP2012H Self-test Web Page</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="keywords" content="" />
<!--link rel="stylesheet" href="img/Underground.css" type="text/css" /-->
<!-- Bubble tooltips: adopted from: http://www.web-graphics.com/mtarchive/BubbleTooltips.html--><!-- For automatic tooltip: -->
<script src="bubbletooltips/bubbletooltips.js" type=text/javascript></script>
<!-- Example:  usage <a href="" title=""></a>  --><!-- For customize tooltip -->
<link media=all href="bubbletooltips/bt.css" type=text/css rel=stylesheet>
<script type="text/javascript" src="jquery/jquery.js"></script>

<!-- JQuery Calender is located here... -->
<style type="text/css">@import url(jquerycalendar/jquery-calendar.css);</style>
<script type="text/javascript" src="jquerycalendar/jquery-calendar.js"></script>

<script type="text/javascript" src="selftestmenu.js"></script>
<link rel="stylesheet" type="text/css" href="selfteststyle.css" />
<!-- highslide stuff: TESTING... -->
<script type="text/javascript" src="highslide/highslide-with-html.js"></script>
<script type="text/javascript">
    hs.graphicsDir = 'highslide/graphics/';
    hs.outlineType = 'rounded-white';
    hs.outlineWhileAnimating = true;
</script>
<style type="text/css">@import url(highslide/myslide.css);</style>
<!-- END OF highslide stuff -->

</head>

<!-- Start of the main html body -->
<body>

<!-- wrap starts here -->
<div id="main">
<div id="wrap">
        <!-- header -->
        <div id="header">
                <span id="slogan" ></span>
                <!-- tabs -->
                <ul>
                  <li class="showall-solution"><a href="#" title="Show all solutions"><span>Show all solutions</span></a></li>
                  <li class="hideall-solution"><a href="#" title="Hide all solutions"><span>Hide all solutions</span></a></li>

                </ul>
        </div>
        <!-- main block: right panel -->
        <!--div id="main"-->

          <!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Test 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  -->
          <div id='block1' style="display:block;	clear:left;">
            <h1>Self-test 21: <br />  C++11 features (rvalue reference and move semantics) </h1>

          <OL>

            <!-- Start of question 1 -->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>If we have 2 (overloaded) functions with the following prototypes: </p>
<pre>f(const T&);
f(T&&);</pre>
              <p>When calling function f, if the parameter is of the following type, which one of the functions will be invoked?</p>
              <ol>
                <li>const rvalue</li>
                <li>const lvalue</li>
                <li>rvalue reference</li>
                <li>lvalue reference</li>
                <li>temporary value/object</li>
              </ol>
            </div>

            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <p><b>"f(const T&)" will take all (1), (2), (3), (4) while "f(T&&)" will take (5).</b></p>
              <p>"f(T&&)" can only take temporary value/object. While "f(const T&)" can actually also accept temporary value/object as the parameter, the "f(T&&)" will have the priority to be chosen.</p>
            </div>
            </div>
            <hr />
            </LI>
            <!-- End of question 1 -->


			<!-- Start of question 2 -->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>True or false.</p>
              <p>The function std::move() performs the move operation for the given parameter.</p>

            </div>

            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>False.</b> The function std::move() actually does NOT move anything. It only does static casting. It is particularly useful to allow the use of a move constructor/assignment for a lvalue object by casting it to a rvalue reference of the object.
            </div>
            </div>
            <hr />
            </LI>
            <!-- End of question 2 -->


			<!-- Start of question 3 -->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              Consider the following code:
<pre>
#include &lt;iostream&gt;
using namespace std;

class A
{
public:
    A(int x) : n(x) { cout &lt;&lt; "conversion " &lt;&lt; n &lt;&lt; endl; };
    // A(A&& a) : n(a.n) { cout &lt;&lt; "move " &lt;&lt; a.n &lt;&lt; endl; } // what happens if you uncomment this line?
    A(const A& a) : n(a.n) { cout &lt;&lt; "copy " &lt;&lt; a.n &lt;&lt; endl; }

private:
    int n;
};

int main()
{
    A a = 4;
    return 0;
}
</pre>
<p>What would be the output? And what happens if you uncomment the indicated line? In this question, it is assumed that the code is compiled with the flag -fno-elide-constructors.</p>
            </div>

            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>"conversion 4 copy 4 " at first, and "conversion 4 move 4 " after uncommenting the indicated line.</b> Without a move constructor, the copy constructor is invoked after using the conversion constructor to create a temporary A object out of the integer 4. With a move constructor defined, however, the move constructor will have the priority to be chosen.
            </div>
            </div>
            <hr />
            </LI>
            <!-- End of question 3-->


						<!-- Start of question 4-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>When are temporary objects destructed? Any special case?</p>

            </div>

            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <p>Temporary objects are destructed at the end of the expression creating them, unless they are held by rvalue/const references. In the latter case, they live until the rvalue/const references go out-of-scope.</p>
            </div>
            </div>
            <hr />
            </LI>
            <!-- End of question 4 -->


			<!-- Start of question 5-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>Why/when is a move constructor useful? Why not always simply use a copy constructor?</p>
            </div>

            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>It can be more efficient, in terms of both speed and memory usage.</b>
              <p>Consider a case where a class has some dynamically-allocated member objects. For that class, a deep-copy constructor is often needed. We may have a move constructor which will simply move (sometimes swap) resources from its input argument if it is a temporary object of the same class. It is more efficient as no memory allocation is needed. Since, originally, the temporary object is going to be discarded very soon anyway, why not make use of it by "stealing" its allocated resources?</p>
            </div>
            </div>
            <hr />
            </LI>
            <!-- End of question 5 -->

	    <!-- Start of question 6-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>Assume both copy constructor and move constructor are defined. Please write down a line of code to call the move constructor with a locally created object x.</p>
	    <pre>
	    Object x;
	    _____________________ ; //create a new object y using move constructor here.
	    </pre>
            </div>

            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>Object y(std::move(x));</b>
	     <p>
	     </p>
            </div>
            </div>
            <hr />
            </LI>
            <!-- End of question 6 -->

	    <!-- Start of quesiton 7-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>Study the following code and predict the output.</p>
	    <pre>

#include &lt;iostream&gt;
using namespace std;

class A {
public:
    A() { cout &lt;&lt; "Default constructor" &lt;&lt; endl;}

    void operator=(const A& a) { cout &lt;&lt; "operator=(const &)" &lt;&lt; endl; }
    void operator=(const A&& a) { cout &lt;&lt; "operator=(temp obj)" &lt;&lt; endl; }

    A(const A& a) { cout &lt;&lt; "Copy constructor" &lt;&lt; endl; *this = a;}
    A(A&& a) { cout &lt;&lt; "Move constructor" &lt;&lt; endl; *this = a;}
};


int main() {
    A x;
    A y(move(x));
}
	    </pre>
            </div>

            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>It prints Default constructor, Move constructor, and suprisingly = operator (const &).</b>
	     <p>
		<code>A&& a</code> in the move constructor is an r-value reference which should be bound to an incoming temporary A object. However, once it is bound, a is treated like a "normal" object with both rvalue and lvalue. When it is passed to another function, here operator=(), it is treated as a "normal" object. Also note again (as have been tested in Q1) that operator=(const A&&) only accepts temporary objects.
	     </p>
            </div>
            </div>
            <hr />
            </LI>
            <!-- End of quesiton 7 -->

	    <!-- Start of quesiton 8-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>Consider the following code and put either <code>a</code> or <code>move(a)</code> into placeholders __i__, __ii__, __iii__ to make it compile without error.</p>
	    <pre>

#include &lt;iostream&gt;
using namespace std;

class A {
public:
    A () {}
    A (A&& a) { cout &lt;&lt; "move consturctor" &lt;&lt; endl; }
    A (const A& a) { cout &lt;&lt; "copy consturctor" &lt;&lt; endl; }
    A f(A&& a) { cout &lt;&lt; "f(A&&)" &lt;&lt; endl; return __i__; }
    A& g(A&& a) { cout &lt;&lt; "g(A&&)" &lt;&lt; endl; return __ii__; }
    A&& h(A&& a) { cout &lt;&lt; "h(A&&)" &lt;&lt; endl; return __iii__; }
};


int main() {
    A x;
    A y;
    x.f(move(y));
    x.g(move(y));
    x.h(move(y));
}
	    </pre>
            </div>

            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>__i__ : either move(a) or a<br>__ii__ : a<br> __iii__ : move(a)</b>
	     <p>
		Function <code>g</code> needs to return an lvalue reference and move(a) casts a as an rvalue already. It cannot be bound to an lvalue reference. <code>h</code> needs to return an rvalue reference and <code>A&& a</code> is a reference and is an lvalue. For function <code>f</code>, it returns an object and either way works but different constructors will be used. A copy constructor will be called if it returns a. A move constructor will be called if it returns move(a).
	     </p>
            </div>
            </div>
            <hr />
            </LI>
            <!-- End of quesiton 8 -->

        <!-- wrap ends here; don't delete this /div -->
        </div>

</div>
</div>

</body>
</html>

