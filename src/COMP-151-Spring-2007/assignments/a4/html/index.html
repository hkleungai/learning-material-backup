<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>a1: COMP151 Programming Assignment 4, Spring 2007</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>COMP151 Programming Assignment 4, Spring 2007</h1>
<p>
<b>Author:</b> <a href="http://www.cs.ust.hk/~dekai/">Dekai Wu</a><p>
<b>Date:</b> Due 2007.05.15 at 23:00 by CASS<p>
<b>Download:</b> <a href="../../../assignments/a4.tar.gz">http://www.cs.ust.hk/~dekai/151/assignments/a4.tar.gz</a><p>
<b>Assignment page:</b> <a href="../../../assignments/a4/html/">http://www.cs.ust.hk/~dekai/151/assignments/a4/html/</a><p>
<b>Course page:</b> <a href="../../../index.html">http://www.cs.ust.hk/~dekai/151/</a><p>
<h3>Your assignment</h3>
<p>
In this fourth piece of your programming project, you are assigned to maintain and extend the micro-Scheme interpreter you've built in Assignments <a href="../../../assignments/a1/html/">1</a>, <a href="../../a2/html/index.html">2</a>, and <a href="../../../assignments/a3/html/index.html">3</a>, specifically to add function values (by supporting <code>lambda</code>) and function application (by supporting standard Scheme expressions where the first element of the list is any function value, as well as by supporting explicit <code>apply</code> syntax).<p>
For this assignment, we are giving you almost no new code. The tarball a4.tar.gz contains exactly the same files as a3.tar.gz, except for (1) these instructions and (2) a slightly extended <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> interface, in which we define an additional constructor <code>lambda</code>, along with a corresponding type testing predicate <code>procedurep</code>, plus corresponding accessors <code>get_formals</code> and <code>get_body</code>, and (3) a skeleton <code>library.scm</code> file that we'll describe in Step 3 below.<p>
<h3>Step 1: Support lambda, to construct anonymous function values</h3>
<p>
A function is just another kind of value, like int, double, symbol, or cons values. It must be possible to pass function values as parameters and return values, and so forth.<p>
To make a function value, we need a constructor that constructs a <code>ProcedureCell</code> holding the newly constructed function value. You might think this constructor should be called <code>make_procedure</code> (like <code>make_int</code> or <code>make_symbol</code>), but the historical convention is to call this constructor <code>lambda</code> instead. (This is analogous to the fact that <code>cons</code> is also really a constructor that you might think should have been called <code>make_cons</code> instead.)<p>
So you will add a new operator to your implementation, <code>lambda</code>, that allows construction of anonymous functions of zero or more arguments, as discussed in lecture:<p>
<code>&gt; (lambda (x y z) (* x y z))<br>
 #&lt;function&gt;<br>
 &gt; (define multiply (lambda (x y z) (* x y z)))<br>
 ()<br>
 &gt; (define multiply-tracing (lambda (x y z) (print (quote multiplying..)) (* x y z)))<br>
 ()</code><p>
When a <code>lambda</code> expression is evaluated, it should cause the <code>lambda</code> constructor in the newly extended <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> interface to be called in order to construct a new <code>ProcedureCell</code> holding the new function value. (Remember, think of the <code>lambda</code> constructor just as if it were instead called <code>make_procedure</code>.)<p>
The behavior of <code>lambda</code> should exactly conform to <a href="http://www.schemers.org/Documents/Standards/R5RS/">Scheme R5RS</a>, as described in lecture. It requires two or more operands. The first operand must be a list of symbols (for instance <code>(x y z)</code> in the above example), which describes the formal parameters of the function. The rest of the operands must be a sequence of expressions, describing the body of the function.<p>
You should store the list of arguments in the <code>formals</code> field of the <code>ProcedureCell</code>. You should store the list of expressions in the body (for instance <code>((print (quote multiplying..)) (* x y z))</code> in the above example) in the <code>body</code> field of the <code>ProcedureCell</code>.<p>
<h3>Step 2: Support function application</h3>
<p>
You are now in a position to add the ability to apply the functions, whether anonymous or named. You should support both the normal Scheme syntax where the first element of the list is a function value, as well as explicit <code>apply</code> syntax:<p>
<code>&gt; ((lambda (x y) (+ x y)) 2 3)<br>
 5<br>
 &gt; (multiply 2 3 4)<br>
 24<br>
 &gt; (multiply-tracing 2 3 4)<br>
 multiplying..<br>
 24<br>
 &gt; (apply multiply (quote (2 3 4)))<br>
 24<br>
 &gt; (define apply-to-2-3-4 (lambda (f) (apply f (quote (2 3 4)))))<br>
 ()<br>
 &gt; (apply-to-2-3-4 multiply)<br>
 24<br>
 &gt; ((quote multiply) 2 3 4)<br>
 ERROR: cannot apply a value that is not a function<br>
 &gt; (apply (quote multiply) (quote 2 3 4))<br>
 ERROR: cannot apply a value that is not a function<br>
 &gt; (apply-to-2-3-4 (quote multiply))<br>
 ERROR: cannot apply a value that is not a function</code><p>
To accomplish this, you'll want to implement an additional virtual function <code>apply()</code> for <code>Cell</code> and its derived classes. In particular, the real work of applying a function should be done by <code>Cell* ProcedureCell::apply(Cell* const args)</code> where <code>this</code> points to a <code>ProcedureCell</code> holding the function to be applied, and <code>args</code> points to a list of values to be supplied as the arguments the function is being called with. You can then use your <code>apply()</code> to support both the normal Scheme syntax where the first element of the list is a function value, as well as the explicit <code>apply</code> syntax.<p>
<em>All</em> expressions in the body must be eagerly evaluated, in left-to-right order. This guarantees that the program:<p>
<code>&gt; (define foo (lambda () (print (quote Hello)) (print (quote world)) (print (quote !!))))<br>
 ()<br>
 &gt; (foo)<br>
 Hello<br>
 world<br>
 !!<br>
 ()</code><p>
will print out the desired words in order. (Also notice that in this example, the lambda expression constructs a function that takes zero arguments.)<p>
Similarly, <em>all</em> expressions in the argument list must be eagerly evaluated (but we leave the order of evaluation unspecified; that's your choice).<p>
<em>Hint: Distinguish local versus global scope!</em> When you apply a lambda (i.e., apply a function), the parameter names become local variable names. When you are doing symbol name lookup, you need to make sure that local scope takes priority over global scope. First try to find the symbol name in the local symbol table; only if that fails, then try to find it in the global symbol table. For example:<p>
<code>&gt; (define z 3)<br>
 ()<br>
 &gt; ((lambda (x) (+ x z)) 2)<br>
 5<br>
 &gt; (define x 4)<br>
 ()<br>
 &gt; ((lambda (x) (+ x z)) 2)<br>
 5</code><p>
Unlike in Assignment 3, you can no longer get away with just a single global symbol table. Since functions can call functions which can call functions (or even call recursively for an unbounded number of recursions), you will need a <em>stack</em> of symbol tables to keep proper track of <em>local</em> symbol tables. Consider, for example, the following <code>factorial</code> function that takes a single operand <em>n</em> of type <code>int</code>, and returns <em>n</em>! which is also of type <code>int</code>:<p>
<code>&gt; (define factorial (lambda (x) (if (&lt; x 2) 1 (* x (factorial (- x 1))))))<br>
 ()<br>
 &gt; (factorial 1)<br>
 1<br>
 &gt; (factorial 4)<br>
 24<br>
 &gt; (factorial 10)<br>
 3628800</code><p>
Whenever <code>factorial</code> is called, there is a new local variable <code>x</code> that must not be confused with either the global variable <code>x</code> or any other instances of local variables named <code>x</code>. For instance, <code>(factorial 4)</code> has a local variable <code>x</code> bound to 4, but when it calls <code>(factorial 3)</code> there will be a new local variable <code>x</code> bound to 3 that must not be confused with the local variable <code>x</code> associated with <code>(factorial 4)</code>.<p>
So to avoid that kind of confusion, every time a function is called, a new local symbol table must be pushed on the stack, containing all the parameter symbol names as the local variables for that function. Whenever execution of a function is finished, its local symbol table must be popped from the stack.<p>
Remember to review the examples in Assignments 1, 2, and 3 and make sure everything still works.<p>
<h3>Step 3: Start implementing library functions using your own Scheme (not C++)</h3>
<p>
Congratulations!!<p>
You have now implemented your own fully <b>Turing-equivalent</b> programming language. In principle, you can now program anything using your micro-Scheme interpreter, and never have to use C++ again! More precisely, as <a href="http://en.wikipedia.org/wiki/Turing-complete">Wikipedia</a> puts it: <em>In computability theory, an abstract machine or programming language is called Turing complete, Turing equivalent, or (computationally) universal if it has a computational power equivalent to (i.e., capable of emulating) a simplified model of a programmable computer known as the universal Turing machine. Being equivalent to the universal Turing machine essentially means being able to perform any computational task &ndash; though it does not mean being able to perform such tasks efficiently, quickly, or easily... The term derives from the name of mathematician Alan Turing who introduced the model of the universal Turing machine.</em><p>
This means that from now on, you can implement the rest of your micro-Scheme programming language, using <em>only</em> micro-Scheme. We have used C++ to <b>bootstrap</b> your implementation of the micro-Scheme programming language, and the rest can be done in micro-Scheme itself. You don't have to use C++ any more (well, maybe for a few special purpose convenience items). Hurrah! COMP151 is almost over, and we can start learning other interesting languages besides C++.<p>
You'll celebrate by using your interpreter to start implementing general-purpose library functions <b>using your micro-Scheme language</b> (not using C++). For example, the <code>factorial</code> function above is actually a real function in the standard Scheme specification, which you see you can implement in your own micro-Scheme instead of using C++. Similarly, the operators <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, and <code>abs</code> are all general-purpose library functions that you can implement as follows using your micro-Scheme language rather than C++, as follows (for simplicity, we're providing just the versions that take exactly two operands):<p>
<code>&gt; (define &gt; (lambda (x y) (&lt; y x)))<br>
 ()<br>
 &gt; (&gt; 2 5)<br>
 0<br>
 &gt; (define &gt;= (lambda (x y) (not (&lt; x y))))<br>
 ()<br>
 &gt; (&lt;= 3 2)<br>
 0<br>
 &gt; (define &lt;= (lambda (x y) (not (&lt; y x))))<br>
 ()<br>
 &gt; (&lt;= 3 3)<br>
 1<br>
 &gt; (define = (lambda (x y) (if (&lt; x y) 0 (not (&lt; y x)))))<br>
 ()<br>
 &gt; (= 2 2)<br>
 1<br>
 &gt; (= 2 3)<br>
 0<br>
 &gt; (= 3 2)<br>
 0<br>
 &gt; (define abs (lambda (x) (if (&lt; x 0) (- 0 x) x)))<br>
 ()<br>
 &gt; (abs 3)<br>
 3<br>
 &gt; (abs -3)<br>
 3</code><p>
Are you getting the hang of it yet?<p>
The required additional library function you will implement is <code>for-each</code>, which does something kind of similar to the STL <code>for_each</code> generic algorithm for C++ that we studied in lecture.<p>
Your <code>for-each</code> function should take two operands, where the first operand must be a function of one argument, and the second operand must be a list. It should apply the function to every element in the list. The return value of <code>for-each</code> is unspecified (so you could return <code>()</code>, for example).<p>
<code>(for-each</code> <em>&lt;function&gt; &lt;list&gt;</em><code>)</code> <p>
For example:<p>
<code>&gt; (define square (lambda (x) (print (* x x))))<br>
 ()<br>
 &gt; (for-each square (quote (2 5 9 14 256)))<br>
 4<br>
 25<br>
 81<br>
 196<br>
 65536<br>
 ()</code><p>
You can also consult <a href="http://www.schemers.org/Documents/Standards/R5RS/">Scheme R5RS</a> for details of <code>for-each</code>.<p>
Please feel free to implement any other general-purpose library functions you would like, just for fun. Some suggestions: the general <code>map</code> and <code>reduce</code> functions and the <code>list</code> function. These require you to have implemented the optional bonus support for a variable number of formal parameters for <code>lambda</code>, as described below.<p>
When you are finished, add <b>all</b> your Scheme library functions to the <code>library.scm</code> file where we've already placed the libary functions <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, <code>abs</code> and <code>factorial</code> to get you started. Make sure your improved version of <code>library.scm</code> is included in your tarball submission.<p>
<h3>Optional bonus: Support a variable number of arguments</h3>
<p>
The following is purely for fun. You are <em>not</em> required to do it! Only try this if you are bored or want to impress me :-)<p>
If you wish, you may also implement Scheme's support for variable number of arguments.<p>
<code>&gt; (define first (lambda args (car args)))<br>
 &gt; (first (quote a) (quote b) (quote c))<br>
 a<br>
 &gt; (first (quote a) (quote b) (quote c) (quote d) (quote e) (quote f))<br>
 a</code><p>
The key here is that <code>args</code> is a symbol rather than a list of symbols. You can consult <a href="http://www.schemers.org/Documents/Standards/R5RS/">Scheme R5RS</a> for more details.<p>
If you do this optional bonus, then notice it will also let you implement the general version of the <code>for-each</code> function as defined in <a href="http://www.schemers.org/Documents/Standards/R5RS/">Scheme R5RS</a> so that the first operand can be a function that takes any number of operands:<p>
<code>(for-each</code> <em>&lt;function&gt; &lt;list1&gt; &lt;list2&gt; ...</em><code>)</code> <p>
Definitely don't try this unless you have everything else in this assignment perfectly done!<p>
<h3>Optional bonus: Support the `<code>let</code>' syntactic sugar</h3>
<p>
If you are finished with all the optional bonuses so far, you can try this. Again, the following is purely for fun, and you are <em>not</em> expected to do it unless you want to.<p>
You may also wish to implement Scheme's support for the <code>let</code> syntactic sugar for <code>lambda</code>. This can make programming with local variables much more convenient and readable. You can also consult <a href="http://www.schemers.org/Documents/Standards/R5RS/">Scheme R5RS</a> for more details.<p>
The <code>let</code> syntax is an alternate syntax for lambda expressions, that more closely resembles local (const) variable definitions in other languages you're familiar with, like C++. For example, the following two expressions have identical meaning:<p>
<code>&gt; ((lambda (x y) (* x y)) 2 3)<br>
 6<br>
 &gt; (let ((x 2) (y 3)) (* x y))<br>
 6</code><p>
If we rewrite the latter expression with better indentation, it looks like this:<p>
<code>(let ((x 2)<br>
 ������(y 3))<br>
 ��(* x y))<br>
 </code><p>
which looks much like the roughly equivalent C++ code:<p>
<code>{<br>
 ��int x(2);<br>
 ��int y(3);<br>
 ��return x * y;<br>
 }<br>
 </code><p>
So in fact, <code>lambda</code> not only implements functions, but also implements local variables!<p>
<h3>Putting it all together and testing your implementation</h3>
<p>
Except for the modified version of <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> and the new <code>library.scm</code>, all other source files in <code>a4.tar.gz</code> are identical to those from <code>a3.tar.gz</code>.<p>
So you should start from your Assignment 3 implementation and extend it, replacing only the old <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> with the new one. Be careful! You still may not break any of the encapsulation rules from Assignment 3.<p>
Remember again, the objective of this programming project is for you to train your skills, by practicing correct software engineering techniques enabling you to build, maintain, and extend a non-trivial piece of well-engineered code.<p>
<h3>Important reminders</h3>
<p>
You must follow the design approach outlined in this document. Do <em>not</em> just implement the required functionality using a different design.<p>
This time you <em>must</em> use templates. In this assignment, you are expected to make good use of the STL <code>map</code> - but neatly, without messing up the polymorphic approach you built in Assignment 2.<p>
Remember we are focusing on proper use of encapsulation. So you still should <em>not</em> edit the files <code><a class="el" href="parse_8hpp.html">parse.hpp</a></code>, <code><a class="el" href="parse_8cpp.html">parse.cpp</a></code>, <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code>, <code><a class="el" href="eval_8hpp.html">eval.hpp</a></code>, or <code><a class="el" href="main_8cpp.html">main.cpp</a></code>. Again, the programming assignments are mini-exercises in how multiple programmers are supposed to interact and communicate in the real world; these files are <em>owned</em> and <em>maintained</em> by the other author(s).<p>
The tarball you turn in will need to contain your new or extended implementations of <code>eval.cpp</code>, <code><a class="el" href="Cell_8hpp.html">Cell.hpp</a></code>, <code>Cell.cpp</code>, and <code>library.scm</code>.<p>
Depending on your approach, you may or may not need to change the <code>Makefile</code>. Whether you changed it or not, always make sure you include whatever <code>Makefile</code> is needed to build your program, when you submit assignment. Otherwise, the graders cannot build your program.<p>
You must write the final version of the program on your own. Sophisticated plagiarism detection systems are in operation, and they are pretty good at catching copying! If you worked in study groups, you must also acknowledge your collaborators in the write-up for each problem, whether or not they are classmates. Other cases will be dealt with as plagiarism. Re-read the policy on the course home page, and note the University's tougher policy this year regarding cheating.<p>
<b>Your programming style (how clearly and how well you speak C++) is what will be graded. Correct functioning of your program is necessary but not sufficient!</b> <hr size="1"><address style="align: right;"><small>Generated on Wed May 9 22:06:39 2007 for a1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
