Problem 1 SML (15 pts)
(a) 4
(b) [8,6]
(c) 12


Problem 2 Type inference (15 pts)
(a) val foo1 = fn : ('a -> bool) -> 'a -> bool
(b) val foo2 = fn : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
(c) val foo3 = fn : ('a * 'b -> bool) -> 'a list -> 'a list -> 'b -> 'a list -> 'a list * 'a list

                                             
Problem3 SML Tree (20 pts)
   (a) fun exist(v, nil) = false |       
     exist(v, node(v1, l,r)) = if v=v1 then true      
                               else (exist(v,l) orelse exist(v,r));   
   
   (b) fun insert(v, nil) = node(v,nil,nil) |   
       insert(v, node(v1, l, r)) = if v>v1 then node(v1, l, insert(v,r))   
                                         else node(v1, insert(v, l), r);   
 
   (c) fun traverse nil = [] |
           traverse (node(v, l, r)) = (traverse l)@ [v] @(traverse r);   
  
   (d)fun search (v, nil) = [] |  
           search (v, node(v1, l, r)) = if v = v1 then [v]  
                                            else if v>v1 then v1::search(v,r) 
                                            else v1::search(v,l);             

    
Problem 4 BNF, ab-string (15 pts)
(a) <empty>, ab, ba, aabb, bbaa, abba, baab, abab, baba.

(b) No.
    String "aaabbb" can be generated by the grammar, but not by the regular expression.


Problem 5 Grammar (15 pts)
(a)	<S> ::= <S>  -  <X> | <X>
	<X> ::= <X> U <Y> | <Y>
	<Y> ::= <Y> n <Z> | <Z>
	<Z> ::= A | B | C | D | E

(b) The tree representation is as follows, where leaf node are letters and internal nodes are oprators.

                -
               / \
              -   E
	     / \
            A   U
               / \    
              B   n
                 / \
                C   D


Problem 6 Grammar (20 pts)
(a)
<S> ::= <R> -> <S> | <R>
<R> ::= <R> * <T> | <T>
<T> ::= <T> list | <U>
<U> ::= ( <S> ) | bool | int | real | string


(b)

                                  <S>
                           /       |            \
                          /        |             \
                         /         |              \
                        /          |               \
                       /           |                \
                      /            |                 \
                     /             |                  \
                    /              |                   \		
                   /               |                    \
                <R>                ->                   <S>
                 |                              /        |         \
                <T>                          <R>         ->        <S>
             /       \                        |                     |
           <T>      list                     <T>                   <R>
            |                                 |                     | 
           <U>                               <U>                   <T>
            |                            /    |    \            /       \
          string                        (    <S>    )         <T>      list
                                          /   |   \            |
                                        <R>   ->  <S>         <U>
                                         |         |        /  |  \
                                        <T>       <R>      (  <S>  )
                                         |         |           |
                                        <U>       <T>         <R>
                                         |         |        /  |  \
                                       string     <U>     <R>  *  <T>
                                                   |       |       |
                                                  int     <T>     <U>
                                                           |       |
                                                          <U>     int
                                                           |
                                                         string
