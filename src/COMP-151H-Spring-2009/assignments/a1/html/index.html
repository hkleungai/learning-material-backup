<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>a1: COMP151H Programming Assignment 1, Spring 2009</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>COMP151H Programming Assignment 1, Spring 2009</h1>
<p>
<b>Author:</b> <a href="http://www.cs.ust.hk/~dekai/">Dekai Wu</a><p>
<b>Date:</b> Due 2009.03.17 at 23:00 by CASS<p>
<b>Download:</b> <a href="../../../assignments/a1.tar.gz">http://www.cs.ust.hk/~dekai/151h/assignments/a1.tar.gz</a><p>
<b>Assignment page:</b> <a href="../../../assignments/a1/html/">http://www.cs.ust.hk/~dekai/151h/assignments/a1/html/</a><p>
<b>Course page:</b> <a href="../../../index.html">http://www.cs.ust.hk/~dekai/151h/</a><p>
<h3>Your assignment</h3>
<p>
You've been assigned to write an <em>expression evaluator</em>. The input expressions to your evaluator will be strings in a traditional computer science notation known as <a href="http://en.wikipedia.org/wiki/S-expression"><em>s-expressions</em></a>, which is a prefix notation that is fully parenthesized to avoid ambiguity, for example:<p>
<code>(+ 2 3 4 5)</code><br>
 <code>(+ 2 3.5)</code><br>
 <code>(+ 2)</code><br>
 <code>(+)</code><br>
 <code>(+ (+ -2 5 -1) 3.5)</code><br>
 <code>(ceiling 4.7)</code><br>
 <code>(ceiling 4.0)</code><br>
 <code>(ceiling -4.7)</code><br>
 <code>(if 5 7 8.3)</code><br>
 <code>(if 0 7 8.3)</code><br>
 <code>(if (+ 2 3) (ceiling 6.1) (+ 4 2.3 2))</code><br>
 <code>(if (+ 2 -2) (ceiling 6.1) (+ 4 2.3 2))</code><br>
 <code>(+ 1 (if (+ 2 -2) (ceiling 6.1) (+ 4 2.3 2)))</code><p>
Notice that you're dealing with three distinct types of atomic elements in these expressions: <em>ints</em>, <em>doubles</em>, and <em>symbols</em>. The <em>ints</em> and <em>doubles</em> are two different types of literals used as operands. In addition, the operator <em>symbols</em> are functions whose symbol names are <code>+</code>, <code>if</code>, and <code>ceiling</code>.<p>
The <code>+</code> operator accepts any number of operands to be added. The operands can be any mix of ints or doubles. Like in C or C++, the return type should be double if any of the operands are double, and int otherwise. If no operands are given, then the result should be zero which is the identity value for addition.<p>
The <code>ceiling</code> operator requires exactly one operand, which must be a double. It returns an int which is the smallest integer that is greater or equal to the operand.<p>
The <code>if</code> operator requires either two or three operands. It first checks if the first operand is non-zero. If so, then it should return the result of evaluating the second operand. Otherwise, it should return the result of evaluating the third operand (if only two operands were given, then the return value is undefined, or in other words, you may return anything you like).<p>
Also notice that operands do not have to be literals. They also can recursively be sub-expressions.<p>
Given such an input expression, your evaluator should return the result of evaluating the expression, for example:<p>
<code>(+ 2 3 4 5)</code> should return the int <code>14</code><br>
 <code>(+ 2 3.5)</code> should return the double <code>5.5</code><br>
 <code>(+ 2)</code> should return the int <code>2</code><br>
 <code>(+)</code> should return the int <code>0</code><br>
 <code>(+ (+ -2 5 -1) 3.5)</code> should return the double <code>5.5</code><br>
 <code>(ceiling 4.7)</code> should return the int <code>5</code><br>
 <code>(ceiling 4.0)</code> should return the int <code>4</code><br>
 <code>(ceiling -4.7)</code> should return the int <code>-4</code><br>
 <code>(if 5 7 8.3)</code> should return the int <code>7</code><br>
 <code>(if 0 7 8.3)</code> should return the double <code>8.3</code><br>
 <code>(if (+ 2 3) (ceiling 6.1) (+ 4 2.3 2))</code> should return the int <code>7</code><br>
 <code>(if (+ 2 -2) (ceiling 6.1) (+ 4 2.3 2))</code> should return the double <code>8.3</code><br>
 <code>(+ 1 (if (+ 2 -2) (ceiling 6.1) (+ 4 2.3 2)))</code> should return the double <code>9.3</code><p>
Your expression evaluator should proceed in two independent stages: <ol>
<li>
<em>Parse</em> the input string to analyze and understand its structure. The parser should return a tree data structure in which it records (a) the nested structure of the parenthesized expressions and sub-expressions, and (b) the types of all the elements in the expression. </li>
<li>
<em>Evaluate</em> the expression stored in the tree data structure, by doing a depth-first traversal. The evaluator should return the value resulting from evaluating the entire expression. </li>
</ol>
<p>
If there is any error in the types or number of operands in the input expression, your expression evaluator should print the string <code>ERROR</code> on standard error (<code>cerr &lt;&lt; "ERROR"</code>), and call <code>exit(1)</code> to terminate program execution. Otherwise, for this assignment, you may assume that you will only be tested with input expressions that can safely be parsed.<p>
<h3>Borrowing someone else's expression parser</h3>
<p>
Thankfully, you don't have to write a parser. You've already found a parser written by someone else, capable of reading and understanding strings in s-expression format. Download the package at the top of this page, then:<p>
<code>$ tar xzf a1.tar.gz</code> <em>// unpack the archive</em><br>
 <code>$ cd a1</code><br>
 <code>$ make</code><br>
 <code>g++ -c <a class="el" href="main_8cpp.html">main.cpp</a></code><br>
 <code>g++ -c <a class="el" href="parse_8cpp.html">parse.cpp</a></code><br>
 <code>g++ -c <a class="el" href="eval_8cpp.html">eval.cpp</a></code><br>
 <code>g++ -c <a class="el" href="Cell_8cpp.html">Cell.cpp</a></code><br>
 <code>g++ -DOP_ASSIGN -o main main.o parse.o eval.o Cell.o -lm</code><br>
 <code>$ main testinput.txt</code><p>
You will see the parser's test program run. You can also run the program in interactive mode by typing <code>main</code> without any command-line arguments. In interactive mode, the program will prompt you to type in an expression, and then it'll print the expression back to you, and repeat until you type control-D to generate an EOF (end-of-file).<p>
You wish to re-use this code for parsing s-expressions. The only problem is that this parser, as originally written, does not actually build a tree data structure. So you will need to modify the code to suit the purposes of this assignment.<p>
But you are lucky that the author of the parser encapsulated his code quite neatly. You will not even have to touch his parser code (which is in <code><a class="el" href="parse_8hpp.html">parse.hpp</a></code> and <code><a class="el" href="parse_8cpp.html">parse.cpp</a></code>). As the parser analyzes the input string, it needs to call various operations to record the nested tree structure that it is finding in the s-expression. The author wisely encapsulated all these operations and global constants in a separate header file <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> that keeps all the concrete tree implementation details hidden from the parser: <ul>
<li>
<code>Cell* <a class="el" href="cons_8hpp.html#bd08cd408e6d3668dbee6252a9019ab5" title="Make an int cell.">make_int(const int i)</a></code> returns a newly constructed int cell, i.e., a leaf node initialized to hold the int value <code>i</code> </li>
<li>
<code>Cell* <a class="el" href="cons_8hpp.html#775d8fa6ca20226c185ab648fda89be0" title="Make a double cell.">make_double(const double d)</a></code> returns a newly constructed double cell, i.e., a leaf node initialized to hold the double value <code>d</code> </li>
<li>
<code>Cell* <a class="el" href="cons_8hpp.html#967663e2ad68f27d92d386701a54dd11" title="Make a symbol cell.">make_symbol(const char* const s)</a></code> returns a newly constructed symbol cell, i.e., a leaf node initialized to hold the symbol name <code>s</code> </li>
<li>
<code>Cell* <a class="el" href="cons_8hpp.html#07f5328fc7048999bd2f3085b71b46cf" title="Make a conspair cell.">cons(Cell* const my_car, Cell* const my_cdr)</a></code> returns a newly constructed cons cell, i.e., an internal node initialized to hold the two pointers <code>my_car</code> and <code>my_cdr</code> </li>
</ul>
<ul>
<li>
<code>bool <a class="el" href="cons_8hpp.html#638ff923dd35f1011cd4ee1e36b4d331" title="Check if c points to an int cell.">intp(Cell* const c)</a></code> returns true iff the cell pointed to by <code>c</code> is an int cell </li>
<li>
<code>bool <a class="el" href="cons_8hpp.html#a2467dd96e45c9a31f1175fbb0db169f" title="Check if c points to a double cell.">doublep(Cell* const c)</a></code> returns true iff the cell pointed to by <code>c</code> is a double cell </li>
<li>
<code>bool <a class="el" href="cons_8hpp.html#ed09457ad59056d585482b214b25312b" title="Check if c points to a symbol cell.">symbolp(Cell* const c)</a></code> returns true iff the cell pointed to by <code>c</code> is a symbol cell </li>
<li>
<code>bool <a class="el" href="cons_8hpp.html#85e879380cf1487e338759df2babb1ad" title="Check if c points to an empty list, i.e., is a null pointer.">nullp(Cell* const c)</a></code> returns true iff <code>c</code> is is the null pointer (which is equivalent to the empty list) </li>
<li>
<code>bool <a class="el" href="cons_8hpp.html#9c29ee781665ba58b41a96ffcd327c7c" title="Check if c points to a list (i.e., nil or a cons cell).">listp(Cell* const c)</a></code> returns true iff the cell pointed to by <code>c</code> is a cons cell, or if <code>c</code> is the null pointer (i.e., if c points to an empty list) </li>
</ul>
<ul>
<li>
<code>extern Cell* const nil</code> holds the value of a null pointer, which we consider equivalent to an empty list </li>
</ul>
<ul>
<li>
<code>int <a class="el" href="cons_8hpp.html#8ac79ad8842af8e8de13d6436b7f2e67" title="Accessor (error if c is not an int cell).">get_int(Cell* const c)</a></code> returns the value in the int cell pointed to by <code>c</code> (error if <code>c</code> is not an int cell) </li>
<li>
<code>double <a class="el" href="cons_8hpp.html#d3d01dbbac1ebd184d5c97dc7b82188b" title="Accessor (error if c is not a double cell).">get_double(Cell* const c)</a></code> returns the value in the double cell pointed to by <code>c</code> (error if <code>c</code> is not a double cell) </li>
<li>
<code>string <a class="el" href="cons_8hpp.html#df923daca4be44e8a40a827fe4f4c58a" title="Retrieve the symbol name as a string (error if c is not a symbol cell).">get_symbol(Cell* const c)</a></code> returns the value in the string cell pointed to by <code>c</code> (error if <code>c</code> is not a string cell) </li>
<li>
<code>Cell* <a class="el" href="cons_8hpp.html#f4c7523051c64ad2caa338d0f288fcff" title="Accessor (error if c is not a cons cell).">car(Cell* const c)</a></code> returns the car pointer of the cons cell pointed to by <code>c</code> (error if <code>c</code> is not a cons cell) </li>
<li>
<code>Cell* <a class="el" href="cons_8hpp.html#791b6a776b87bb31bd0338d477983287" title="Accessor (error if c is not a string cell).">cdr(Cell* const c)</a></code> returns the cdr pointer of the cons cell pointed to by <code>c</code> (error if <code>c</code> is not a cons cell) </li>
</ul>
<ul>
<li>
<code>ostream&amp; operator&lt;&lt;(ostream&amp; os, Cell* const c)</code> prints the cons cell pointed to by <code>c</code> to the output stream <code>os</code>, using s-expression notation </li>
</ul>
<p>
Notice that even though these are just ordinary functions (not member functions of a class), nevertheless this set of functions constitutes an interface for an abstract data type; we'll discuss more background on this particular ADT below. The way that <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> specifies the ADT interface is nice because it makes very few assumptions about how the concrete implementation might be done. (Good object-oriented programming style does <em>not</em> necessarily require using classes! For example, see Scott Myer's article <a href="http://www.ddj.com/dept/cpp/184401197">How Non-Member Functions Improve Encapsulation</a>.)<p>
The file <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> that came with the parser just connects all the functions to a dummy example implementation of the ADT that makes use of a super-simple, incomplete <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> class probably written by someone else (found in <code><a class="el" href="Cell_8hpp.html">Cell.hpp</a></code> and <code><a class="el" href="Cell_8cpp.html">Cell.cpp</a></code>). As mentioned earlier, this dummy example implementation isn't actually capable of building a tree data structure with pointers and nodes. Instead, it just records the sub-trees using a string encoding, rather than a tree data structure. Most of the functions needed by <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> aren't even working yet in the dummy <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> class, since the basic parser can be run without the accessor functions <code>intp</code>, <code>doublep</code>, <code>symbolp</code>, <code>nullp</code>, <code>listp</code>, <code>get_int</code>, <code>get_double</code>, <code>get_symbol</code>, <code>car</code> and <code>cdr</code>. You can build trees without using these accessor functions, although it's not terribly useful without the accessor functions since nobody can access the tree you've built. (And in fact, the string encoding that's used is actually just s-expression notation again! Of course this circular set-up is not terribly useful, either; it's just a partial example to show you how to work with the <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> ADT interface by connecting it to a concrete implementation in <code><a class="el" href="Cell_8hpp.html">Cell.hpp</a></code>.)<p>
So the parser author (me) and the tree data structure author (you) both have interfaces encapsulating our code, helping us to divide and conquer the work in <em>both</em> directions: <ul>
<li>
<code><a class="el" href="parse_8hpp.html">parse.hpp</a></code> is the interface that tells you <em>what</em> the parser can do, while hiding the dirty implementation details of <em>how</em> the parser works (in my <code><a class="el" href="parse_8cpp.html">parse.cpp</a></code> which your tree data structure doesn't get to see). </li>
<li>
<code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> is the interface that tells me what the tree data structure can do, while hiding the dirty implementation details of how the tree data structure works (in your <code><a class="el" href="cons_8hpp.html">Cons.hpp</a></code> and <code>Cons.cpp</code> which my parser doesn't get to see). </li>
</ul>
<p>
<h3>Adapting the parser to this assignment</h3>
<p>
You realize that the cleanest and easiest way to proceed is to leave <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> exactly the way it is. That way, you only need to replace the <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> class with your own implementation. (This is good software engineering at work, helping you through proper encapsulation!)<p>
You will also stick to re-using the existing interface of the <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> class when implementing your own version of <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code>; you won't delete or rename any functions or member functions, to avoid breaking the parser. (However, you might wish to add some new functions and member functions, to support manipulating and accessing the tree data structure you build.)<p>
Looking at the public interface specified by the <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> class in <code><a class="el" href="Cell_8hpp.html">Cell.hpp</a></code>, you see there are a few constructors that the parser's <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> will expect your own implementation to provide: <ul>
<li>
<code>Cell(const int i)</code> constructs an int cell, i.e., a leaf node that holds the int value <code>i</code> </li>
<li>
<code>Cell(const double d)</code> constructs a double cell, i.e., a leaf node that holds a double value <code>d</code> </li>
<li>
<code>Cell(const char* const s)</code> constructs a symbol cell, i.e., a leaf node that holds the symbol name <code>s</code> </li>
<li>
<code>Cell(Cell* const my_car, Cell* const my_cdr)</code> constructs a cons cell, i.e., an internal node that holds two pointers <code>my_car</code> and <code>my_cdr</code> </li>
</ul>
<p>
Other than these constructors, you'll need to implement these public member functions: <ul>
<li>
<code>bool is_int() const</code> returns true iff <code>this</code> is an int cell </li>
<li>
<code>bool is_double() const</code> returns true iff <code>this</code> is a double cell </li>
<li>
<code>bool is_symbol() const</code> returns true iff <code>this</code> is a symbol cell </li>
<li>
<code>bool is_cons() const</code> returns true iff <code>this</code> is a cons cell </li>
</ul>
<ul>
<li>
<code>int get_int() const</code> returns the value in this int cell (error if <code>this</code> is not an int cell) </li>
<li>
<code>double get_double() const</code> returns the value in this double cell (error if <code>this</code> is not a double cell) </li>
<li>
<code>string get_symbol() const</code> returns the symbol name in this symbol cell (error if <code>this</code> is not a symbol cell) </li>
<li>
<code>Cell* get_car() const</code> returns the car pointer of this cons cell (error if <code>this</code> is not a cons cell) </li>
<li>
<code>Cell* get_cdr() const</code> returns the cdr pointer of this cons cell (error if <code>this</code> is not a cons cell) </li>
</ul>
<ul>
<li>
<code>void print(ostream&amp; os) const</code> prints the subtree rooted at this cell, in s-expression notation </li>
</ul>
<p>
In <code><a class="el" href="Cell_8cpp.html">Cell.cpp</a></code> you'll also need to define this global constant, that was declared as an extern in <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> (and in <code><a class="el" href="Cell_8hpp.html">Cell.hpp</a></code> too): <ul>
<li>
<code>Cell* const nil</code> is the value for a null pointer, which we consider equivalent to an empty list. </li>
</ul>
<p>
Hint: depending on your approach, you could choose either to implement <code>nil</code> as the C++ <code>NULL</code> value (the pointer to address zero), or as some unique dummy <code>Cell*</code> value (known as a <em>sentinel</em>, as you should learn in COMP171). If you don't know what this means yet, then don't worry and just implement <code>nil</code> as the C++ <code>NULL</code> value, exactly as in the dummy version of <code><a class="el" href="Cell_8cpp.html">Cell.cpp</a></code> that we give you. The following sections discuss how <code>nil</code> is used.<p>
<h3>Some background on the cons list ADT</h3>
<p>
The abstract data type (ADT) that the parser author chose to use is a traditional <a href="http://en.wikipedia.org/wiki/Lisp_programming_language#Conses_and_lists"><em>cons list</em></a> ADT dating back to around 1958. This ADT only requires a nil or NULL constant representing an empty list (which can be written <code>()</code> using s-expression notation), plus only three essential core operations <a href="http://en.wikipedia.org/wiki/Cons"><em>cons</em></a>, <a href="http://en.wikipedia.org/wiki/Car_and_cdr"><em>car</em></a> and <a href="http://en.wikipedia.org/wiki/Car_and_cdr"><em>cdr</em></a>: <ul>
<li>
<a href="http://en.wikipedia.org/wiki/Cons"><em>cons</em></a> constructs a new list with a given car value and cdr list. For example: <ul>
<li>
<code>cons(1, nil)</code> returns <code>(1)</code> </li>
<li>
<code>cons(1, cons(2, nil))</code> returns <code>(1 2)</code> </li>
<li>
<code>cons(1, cons(2, cons(3, nil)))</code> returns <code>(1 2 3)</code> </li>
<li>
<code>cons(cons(1, cons(2, nil)), cons(3, nil))</code> returns <code>((1 2) 3)</code> </li>
</ul>
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Car_and_cdr"><em>car</em></a> gives the value of the head node of the list. For example: <ul>
<li>
<code>car(cons(1, nil))</code> returns <code>1</code> </li>
<li>
<code>car(cons(cons(1, nil), nil))</code> returns <code>(1)</code> </li>
<li>
<code>car(cons(cons(1, cons(2, nil)), cons(3, nil)))</code> returns <code>(1 2)</code> </li>
</ul>
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Car_and_cdr"><em>cdr</em></a> (pronounced "could-er" or "cudder") gives the list after the head node. For example: <ul>
<li>
<code>cdr(cons(1, cons(2, cons(3, nil))))</code> returns <code>(2 3)</code> </li>
<li>
<code>cdr(cons(cons(1, cons(2, nil)), cons(3, nil)))</code> returns <code>(3)</code> </li>
</ul>
</li>
</ul>
<p>
Building up large trees this way can get a bit tedious, so in practice typically people also define equivalent shorthand functions. Mathematically speaking, such functions are not really necessary, and exist only for the sake of convenience. For example, <ul>
<li>
<a href="http://en.wikipedia.org/wiki/Lisp_programming_language#Conses_and_lists"><em>list</em></a> builds a new list containing the operands. For example: <ul>
<li>
<code>list(1)</code> is shorthand for <code>cons(1, nil)</code> and returns <code>(1)</code> </li>
<li>
<code>list(1, 2, 3)</code> is shorthand for <code>cons(1, cons(2, cons(3, nil)))</code> and returns <code>(1 2 3)</code> </li>
<li>
<code>list(list(1, 2), 3)</code> is shorthand for <code>cons(cons(1, cons(2, nil)), cons(3, nil))</code> and returns <code>((1 2) 3)</code> </li>
</ul>
</li>
</ul>
<p>
To keep your life simple, you are <em>not</em> required to implement <code>list</code> even though we'll use it in written examples later.<p>
<h3>Implementing the cons list ADT</h3>
<p>
How do you implement the cons list ADT? In fact there exist many different implement approaches.<p>
You've decided to use the most traditional approach, which is to use a singly linked list data structure (recall Lab 2). This is the most natural and intuitively obvious way to implement the cons list ADT. As explained in <a href="http://en.wikipedia.org/wiki/Scheme_programming_language#Lists">Wikipedia</a>:<p>
Specifically, each node in the linked list is a cons cell, also called a pair. As the name pair implies, a cons cell consists of two values: the first one is the <code>car</code>, and the second is the <code>cdr</code>. For <code>list(1, 2, 3)</code>, there are three cons cells, or pairs. The first cons cell has the number 1 in the first slot, and a pointer to the second cons cell in the second. The second cons cell has the number 2 in the first slot, and a pointer to the third cons cell in the second slot. The third cons cell has the number 3 in the first slot and a NULL constant in the second slot. The NULL constant is usually represented by <code>()</code>. The cons function constructs these cons cells, which is why <code>cons(1, list(2, 3))</code> gives the list <code>(1 2 3)</code>. <p>
Here's a picture of the linked list to hold <code>((1 2) 3)</code>, using what's known as box-and-pointer notation. Notice how it naturally matches the exact structure of <code>cons(cons(1, cons(2, nil)), cons(3, nil))</code>. There's one box for each <code>cons</code>, and two <code>nil</code> pointers. <div align="center">
<img src="boxandpointer.jpg" alt="boxandpointer.jpg">
</div>
<p>
In this assignment, cells can hold four kinds of values: int, double, symbol, and cons. You need a way to store any of these types of values in your cells. How do you do this efficiently?<p>
The obvious naive way is just to have four data members: <pre>class <a class="el" href="classCell.html" title="Class Cell.">Cell</a> {
...
  int int_m;
  double double_m;
  char* symbol_m;
  ConsPair conspair_m;
};</pre><p>
But this is a terribly inefficient waste of memory. Any instance of a <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> will only be using one of these data members. So a better way is to use a <em>union</em>: <pre>class <a class="el" href="classCell.html" title="Class Cell.">Cell</a> {
...
  union {
    int int_m;
    double double_m;
    char* symbol_m;
    ConsPair conspair_m;
  };
};</pre><p>
Unions exist in both C and C++. A union is sort of like a struct, except that a struct provides memory space to simultaneously store all its members, whereas a union provides memory space to store only one of its members at a time. So this way, we won't waste memory space.<p>
The only problem is: when you're using a union, how do you know <em>which</em> of the data members is the valid one? C++ won't tell you; it is your program's own responsibility to keep track of this. If you don't, you can easily create horrible bugs. For example:<p>
<code>Cell* c = new <a class="el" href="classCell.html" title="Class Cell.">Cell</a>;</code><br>
 <code>c-&gt;double_m = 2.718;</code><br>
 <code>cout &lt;&lt; c-&gt;int_m;</code> <em>// whoops! will print out a garbage int</em><br>
 <code>cout &lt;&lt; c-&gt;symbol_m;</code> <em>// whoops! will either seg fault or do wildly unpredictable things</em><p>
To keep track of which member in the union is currently valid, you should use what's known as a <em>tagged union</em> or <em>discriminated union</em> approach: <pre>class <a class="el" href="classCell.html" title="Class Cell.">Cell</a> {
...
  enum TypeTag {type_int, type_double, type_symbol, type_conspair};
  TypeTag tag_m;
  union {
    int int_m;
    double double_m;
    char* symbol_m;
    ConsPair conspair_m;
  };
};</pre><p>
Now you can write your code so that you make sure that the <code>tag_m</code> always holds an up-to-date value indicating which of the union members is valid at the current time.<p>
<h3>Evaluating the expression tree</h3>
<p>
After you've gotten the parser to store the expression into your real tree data structure (your concrete implementation of the cons list ADT), now you need to write a function that evaluates it.<p>
To do this, you merely need to perform a depth-first traversal starting from the root. As you complete each subtree, the evaluator should return the value resulting from evaluating the sub-expression stored in that subtree. By the time you finish the entire traversal, you will be back at the root---so the evaluator should return the value resulting from evaluating the entire expression.<p>
The problem is: what is the <em>type</em> that should be returned by your evaluator function?<p>
It would seem that this depends on the type of the operands---remember, from the introduction:<p>
<code>(+ 2 3 4 5)</code> should return the int <code>14</code><br>
 <code>(+ 2 3.5)</code> should return the double <code>5.5</code><br>
 <code>(+ (+ 3 -1) 3.5)</code> should return the double <code>5.5</code><br>
 <code>(if 5 7 8.3)</code> should return the int <code>7</code><br>
 <code>(if 0 7 8.3)</code> should return the double <code>8.3</code><br>
 <code>(if (+ 2 3) (+ 4 3) (+ 6 2.3))</code> should return the int <code>7</code><br>
 <code>(if (+ 2 -2) (+ 4 3) (+ 6 2.3))</code> should return the double <code>8.3</code><br>
 <code>(+ 1 (if (+ 2 -2) (+ 4 3) (+ 6 2.3)))</code> should return the double <code>9.3</code><br>
 <code>(ceiling 4.7)</code> should return the int <code>5</code><br>
 <code>(ceiling -4.7)</code> should return the int <code>-4</code><p>
But C++ won't let us write a function that returns different types depending on the result!<p>
To solve this problem, we'll re-use your <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> implementation. Remember, <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> already gives us a way to store different types of values in the same class type, by using a tagged union. So your function evaluator should return a <code>Cell*</code> that points to a <code><a class="el" href="classCell.html" title="Class Cell.">Cell</a></code> holding the value resulting from evaluating the expression: <ul>
<li>
<code>Cell* <a class="el" href="eval_8hpp.html#6e55b5c1dddfa3a8b0885d50cdaec560" title="Evaluate the expression tree whose root is pointed to by c (error if c does not hold...">eval(Cell* const c)</a></code> returns the value resulting from evaluating the expression tree whose root is pointed to by <code>c</code> (error if <code>c</code> is not a well-formed expression) </li>
</ul>
<p>
You'll find this declaration in the header file <code><a class="el" href="eval_8hpp.html">eval.hpp</a></code>, which you should not alter. Place your implementation for the evaluator in your own <code><a class="el" href="eval_8cpp.html">eval.cpp</a></code> file, replacing the dummy <code><a class="el" href="eval_8cpp.html">eval.cpp</a></code> that came with the parser.<p>
When you're implementing the <code>eval</code> function, think carefully about all the different cases (what type are the operands?) The <code>+</code> and <code>if</code> functions can be applied to any combination of the numeric int and double types, but what is the return type? The <code>ceiling</code> function can be applied to double types, but not int types. No function can be applied to the symbol type (yet).<p>
<h3>Putting it all together</h3>
<p>
Notice that the dummy example implementation of <code><a class="el" href="eval_8cpp.html">eval.cpp</a></code> that you have been given doesn't do anything useful. It just returns the same <code>Cell*</code> that was passed to it. That's why running the <code>main</code> program prints out the same s-expression that you give it as input. After you've correctly replaced <code><a class="el" href="eval_8cpp.html">eval.cpp</a></code> with your real evaluator implementation, running the same <code>main</code> program will instead print out the result of evaluation---which is exactly what we want!<p>
So you don't need to touch <code><a class="el" href="main_8cpp.html">main.cpp</a></code> at all. Good encapsulation at work, again!<p>
<h3>Important reminders</h3>
<p>
You must follow the design approach outlined in this document. Do <em>not</em> just implement the required functionality using a different design. Your proper <em>software engineering</em> skills are being graded.<p>
Do <em>not</em> use virtual functions or templates in this assignment. This assignment is about static OO support in C++. (You'll get a chance to use dynamic OO polymorphism and templates in the following assignments...)<p>
Do <em>not</em> edit the files <code><a class="el" href="parse_8hpp.html">parse.hpp</a></code>, <code><a class="el" href="parse_8cpp.html">parse.cpp</a></code>, <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code>, <code><a class="el" href="eval_8hpp.html">eval.hpp</a></code>, or <code><a class="el" href="main_8cpp.html">main.cpp</a></code>. The programming assignments are mini-exercises in how multiple programmers are supposed to interact and communicate in the real world; these files are <em>owned</em> and <em>maintained</em> by the other author(s).<p>
You will need to add things to <code><a class="el" href="Cell_8hpp.html">Cell.hpp</a></code>, but do <em>not</em> delete anything from it. Replace the files <code><a class="el" href="Cell_8cpp.html">Cell.cpp</a></code> and <code><a class="el" href="eval_8cpp.html">eval.cpp</a></code> with your own implementations. Depending on your approach, you may or may not also wish to add more files.<p>
Depending on your approach, you may or may not need to change the <code>Makefile</code> (as in Lab 1). Whether you changed it or not, always make sure you include whatever <code>Makefile</code> is needed to build your program, when you submit the assignment. Otherwise, the graders cannot build your program.<p>
Documentation is also a critically important part of your software engineering. Your use of <code>doxygen</code> comments, as in Lab 3, will be graded.<p>
You must write the final version of the program on your own. Sophisticated plagiarism detection systems are in operation, and they are pretty good at catching copying! If you worked in study groups, you must also acknowledge your collaborators in the write-up for each problem, whether or not they are classmates. Other cases will be dealt with as plagiarism. Re-read the policy on the course home page, and note the University's tougher policy this year regarding cheating.<p>
Your programming style (how clearly and how well you speak C++) is what will be graded. Correct functioning of your program is necessary but not sufficient!<p>
<h3>Grading scheme</h3>
<p>
Below is the <b>grading sheet</b> that will be used by the graders, so you can see what software engineering skills they're checking you for.<p>
Your grade consists of two parts: (1) <b>program correctness</b>, worth 60%. and (2) <b>style &amp; design</b>, worth 40%. Points are deducted for the error types as shown (but the minimum you can get for each part is 0%, so you cannot get negative point scores on either program correctness or style &amp; design).<p>
To assist you with your own testing and debugging, examples of the simple, general, and invalid input test cases (similar to the real ones that will be used by the graders) are found in the files <code>testinput_simple.txt</code>, <code>testinput_general.txt</code>, and <code>testinput_invalid.txt</code>, respectively. The correct results for the valid cases are found in the files <code>testreference_simple.txt</code> and <code>testreference_general.txt</code>.<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>Name:</b>  </td><td>&nbsp;  </td></tr>
<tr>
<td><b>Email:</b>  </td><td>&nbsp;  </td></tr>
<tr>
<td><b>Submission Time: </b> </td><td>&nbsp;  </td></tr>
<tr>
<td><b>Late Penalty:</b>  </td><td>&nbsp;  </td></tr>
<tr>
<td><b>Total Pts: </b> </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ 100 Pts  </td></tr>
</table>
<p>
<table border="2" cellspacing="3" cellpadding="3">
<tr>
<td colspan="3"><b>PROGRAM CORRECTNESS</b> (Maximum: 60 Pts; Minimum: 0 Pts)  </td></tr>
<tr>
<td><em>Description</em> </td><td><em>Pts</em> </td><td><em>Notes</em>  </td></tr>
<tr>
<td>Base Pts. (+60 Pts) </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </td></tr>
<tr>
<td>Program fails to compile. (-60 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td><a class="el" href="classCell.html" title="Class Cell.">Cell</a> class fails (link against reference solution and run tests) (-60 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td><a class="el" href="eval_8cpp.html#6e55b5c1dddfa3a8b0885d50cdaec560" title="Evaluate the expression tree whose root is pointed to by c (error if c does not hold...">eval()</a> does not pass simple test cases. (-15 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td><a class="el" href="eval_8cpp.html#6e55b5c1dddfa3a8b0885d50cdaec560" title="Evaluate the expression tree whose root is pointed to by c (error if c does not hold...">eval()</a> does not pass general test cases. (-15 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td><a class="el" href="eval_8cpp.html#6e55b5c1dddfa3a8b0885d50cdaec560" title="Evaluate the expression tree whose root is pointed to by c (error if c does not hold...">eval()</a> does not handle semantically invalid cases. (-15 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Does print() print s-expressions properly? (-20 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Program prints irrelevant information. (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Encapsulation (Min -40 Pts) <ul>
<li>
Edited <a class="el" href="parse_8hpp.html">parse.hpp</a>, <a class="el" href="parse_8cpp.html">parse.cpp</a>, <a class="el" href="cons_8hpp.html">cons.hpp</a>, <a class="el" href="eval_8hpp.html">eval.hpp</a>, or <a class="el" href="main_8cpp.html">main.cpp</a>. (-40 Pts) </li>
<li>
Accessed functions in the <a class="el" href="classCell.html" title="Class Cell.">Cell</a> class directly. (-30 Pts) </li>
</ul>
</td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>BONUS: Proper destruction (+10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>BONUS: Detailed error messages (+5 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>BONUS: Expressions like <code>((if 1 + ceiling) 3.1)</code> (+5 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td colspan="2"><b>STYLE &amp; DESIGN</b> (Maximum: 40 Pts; Minimum: -100 Pts) </td><td></td></tr>
<tr>
<td><em>Description</em> </td><td><em>Pts</em> </td><td><em>Notes</em>  </td></tr>
<tr>
<td>Base Pts. (+40 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>No Doxygen output. (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Inadequate function level documentation. (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Inadequate algorithm level (i.e. within function) documentation. (-15 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Inadequate variable level documentation (i.e. meaning of the variable). (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Poor readability of function and variable names. (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Improper use of indentation and space. (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Inconsistent naming of functions and variables. (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Incorrect &lsquo;const&rsquo; usage. (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Improper private data encapsulation. (-10 Pts) </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
</table>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Mar 2 17:19:47 2009 for a1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
