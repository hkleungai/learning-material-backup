<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>COMP2012H Self-test Web Page</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="keywords" content="" />
<!--link rel="stylesheet" href="img/Underground.css" type="text/css" /-->
<!-- Bubble tooltips: adopted from: http://www.web-graphics.com/mtarchive/BubbleTooltips.html--><!-- For automatic tooltip: -->
<script src="bubbletooltips/bubbletooltips.js" type=text/javascript></script>
<!-- Example:  usage <a href="" title=""></a>  --><!-- For customize tooltip -->
<link media=all href="bubbletooltips/bt.css" type=text/css rel=stylesheet>
<script type="text/javascript" src="jquery/jquery.js"></script>

<!-- JQuery Calender is located here... -->
<style type="text/css">@import url(jquerycalendar/jquery-calendar.css);</style>
<script type="text/javascript" src="jquerycalendar/jquery-calendar.js"></script>

<script type="text/javascript" src="selftestmenu.js"></script>
<link rel="stylesheet" type="text/css" href="selfteststyle.css" />
<!-- highslide stuff: TESTING... -->
<script type="text/javascript" src="highslide/highslide-with-html.js"></script>
<script type="text/javascript">    
    hs.graphicsDir = 'highslide/graphics/';
    hs.outlineType = 'rounded-white';
    hs.outlineWhileAnimating = true;
</script>
<style type="text/css">@import url(highslide/myslide.css);</style>
<!-- END OF highslide stuff -->

</head>

<!-- Start of the main html body -->
<body>

<!-- wrap starts here -->
<div id="main">
<div id="wrap">
        <!-- header -->
        <div id="header">
                <span id="slogan" ></span>
                <!-- tabs -->
                <ul>
                  <li class="showall-solution"><a href="#" title="Show all solutions"><span>Show all solutions</span></a></li>
                  <li class="hideall-solution"><a href="#" title="Hide all solutions"><span>Hide all solutions</span></a></li>
              
                </ul>
        </div>
        <!-- main block: right panel -->
        <!--div id="main"-->

          <!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Test 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  -->
          <div id='block1' style="display:block;	clear:left;">
            <h1>Self-test 15: <br />  Inheritance and Virtual Function  </h1>

          <OL>

            <!-- Start of question 1 -->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>The inheritance mechanism provides a means of deriving:</p>

              <ol type="A">
                <li>a new class from an existing class.</li>
                <li>a new operator from an existing operator.</li>
                <li>a new set of memory allocation functions from the built-in ones.</li>
                <li>All of the above.</li>
              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>A is correct.</b> Inheritance is a means of reusing code effectively. To derive a new operator from an existing operator or to derive a new set of memory allocation functions from the built-in ones is called operator overloading.
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 1 -->

            			
			<!-- Start of question 2 -->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>The ___________ member function is declared in the base class but is redefined in
            the derived class to override the one in the base class.</p>

              <ol type="A">

                <li>class</li>
                <li>overloaded</li>
                <li>virtual</li>
                <li>operator</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>C is correct.</b> Redefining virtual functions is called overriding as opposed to overloading.
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 2 -->
			
			
			<!-- Start of question 3 -->
<!--
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
	-->		
              <!-- Put the question here -->
<!--
              <p>In public inheritance:</p>

              <ol type="A">

                <li>all members of the base class are inherited and are made public.</li>

                <li>members of the base class that are not private are inherited and retain their access types.</li>

                <li>all members of the base class are inherited and retain their access types.</li>

                <li>only public members of the base class are inherited and they remain public.</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
	-->		
              <!-- Put the solution here -->
<!--
              <b>B is correct.</b> In public inheritance, members of the base class that are not private are inherited and retain their access types. 
            </div>              
            </div>
            <hr />
            </LI>
	-->		
            <!-- End of question 3-->
			
						<!-- Start of question 4-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>State whether each of the following is true or false. If false, explain why.</p>

              <ol type="A">

                <li>Base class constructors are not inherited by derived class.</li>
                <li>A <i>has-a</i> relationship is implemented via public inheritance.</li>
                <li>Inheritance encourages the reuse of proven high-quality software.</li>
                <li>When a derived-class object is destroyed, the destructors are called in the reverse order of the constructors.</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              A) True. B) False. A <i>has-a</i> relationship is implemented via composition. A
            <i>is-a</i> relationship is implemented via public inheritance. C) True. D) True. 
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 4 -->
			
			
			<!-- Start of question 5-->
			<!-- Start of question 6-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>What is the output of following program?</p>
			  
<pre>#include&lt;iostream&gt;
using namespace std;

class P {
  public:
   void print()  { cout <<" Inside P"; }
};
  
class Q : public P {
  public:
   void print() { cout <<" Inside Q"; }
};
  
class R: public Q { };
  
int main(void)
{
  R r; 
  r.print();
  return 0;
}
</pre>

              <ol type="A">

                <li>Inside P</li>
                <li>Inside Q</li>
                <li>Nothing since class R doesn't define the print( ) function</li>
                <li>Compilation error: Ambiguous call to print( )</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>B is correct.</b> The print function is not present in class R. So it is looked up in the inheritance hierarchy. print() is present in both classes P and Q, which of them should be called? The idea is, if there is multilevel inheritance, then function is linearly searched up in the inheritance hierarchy until a matching function is found.
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 6 -->
			
			
				<!-- Start of question 7-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>What is the output of following program?</p>
			  
<pre>#include&lt;iostream&gt;
using namespace std;
 
class Base
{
  public:
    void show() { cout<<" In Base "; }
};
 
class Derived: public Base
{
  public:
    int x;
    void show() { cout<<"In Derived "; }
    Derived() : x(10) { }
};
 
int main(void)
{
    Base *bp, b;
    Derived d;
    bp = &d;
    bp->show();
    cout << bp->x;    
    return 0;
}
</pre>

              <ol type="A">

                <li>Compilation error for the line " bp->show()"</li>
                <li>Compilation error for the line " cout << bp->x"</li>
                <li>In Base 10</li>
                <li>In Derived 10</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>B is correct.</b> A base class pointer can point to a derived class object, but we can only access base class member or virtual functions using the base class pointer.
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 7 -->
			
			
				<!-- Start of question 8-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>Use of virtual functions implies:</p>

              <ol type="A">

                <li>overloading.</li>

                <!-- <li>overriding.</li> -->

                <li>static binding.</li>

                <li>dynamic binding.</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>C is correct.</b> Generally, virtual functions are mainly used when we need to do dynamic binding. 
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 8 -->
			
			
		    <!-- Start of question 9-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>What is the output of following program?</p>
			  
<pre>#include&lt;iostream&gt;
using namespace std;
 
class Base
{
  public:
    virtual void show() { cout<<" In Base\n"; }
};
 
class Derived: public Base
{
  public:
    void show() { cout<<"In Derived\n"; }
};
 
int main(void)
{
    Base *bp = new Derived;
    bp->show();
 
    Base &br = *bp;
    br.show();
 
    return 0;
}
</pre>

              <ol type="A">

                <li>In Base <br>In Base</li>
                <li>In Base <br>In Derived</li>
                <li>In Derived<br> In Derived</li>
                <li>In Derived<br> In Base </li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>C is correct.</b> Since show( ) is a virtual function in the base class, it is also
            virtual in the derived class. It is called according to the type of object being
            referenced or pointed, rather than the type of pointer or reference.
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 9 -->

			
			
		    <!-- Start of question 10-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>What is the output of following program?</p>
			  
<pre>#include&lt;iostream&gt;
using namespace std;
 
class Base
{
  public:
    virtual void show() = 0;
};
 
int main(void)
{
    Base b;
    Base *bp;
    return 0;
}
</pre>

              <ol type="A">

                <li>There are compilation errors in lines "Base b;" and "Base bp;"</li>
                <li>There is compilation error in line "Base b;</li>
                <li>There is compilation error in line "Base bp;"</li>
                <li>No compilation error</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>B is correct.</b> Since Base has a pure virtual function, it becomes an abstract class and an instance of it cannot be created. So there is an error in line "Base b". Note that there is no error in line "Base *bp;". We can have pointers or references of abstract classes.
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 10 -->

        <!-- Start of question 11-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>What is the output of following program?</p>
        
<pre>#include&lt;iostream&gt;
using namespace std;
  
class A
{
  public:
    virtual void fun() { cout << "A::fun() "; }
};
  
class B: public A
{
  public:
   void fun() { cout << "B::fun() "; }
};
  
class C: public B
{
  public:
   void fun() { cout << "C::fun() "; }
};
  
int main()
{
    B *bp = new C;
    bp->fun();
    return 0;
}
</pre>

              <ol type="A">

                <li>A::fun()</li>

                <li>B::fun()</li>

                <li>C::fun()</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>C is correct.</b> The important thing to note here is B::fun() is virtual even if
            we have not uses virtual keyword with it. When a class has a virtual function, functions
            with the same signature in all its descendant classes automatically become virtual. We
            don't need to use the virtual keyword in declaration of fun( ) in B and C. They are
            anyways virtual, but it is a good practice to add the virtual keyword to those functions
            in the derived classes.
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 11 -->
 

       <!-- Start of question 12-->
            <LI>
            <div class="question-wrapper">
            <div class="question-content">
              <!-- Put the question here -->
              <p>What is the output of following program?</p>
        
<pre>#include&lt;iostream&gt;
using namespace std;
 
class Base
{
  public:
    virtual void show() { cout << "In Base\n"; }
};
 
class Derived: public Base
{
  public:
    virtual void show() { cout << "In Derived\n"; }
};
 
int main(void)
{
    Base *bp = new Derived;
    bp->Base::show();  // Note the use of scope resolution here
    return 0;
}
</pre>

              <ol type="A">

                <li>In Base</li>

                <li>In Derived</li>

                <li>Compilation error</li>

                <li>Runtime Error</li>

              </ol>
            </div>
        
            <div class="toggle-solution">Solution</div>
            <div class="solution-content">
              <!-- Put the solution here -->
              <b>A is correct.</b> A base class function can be accessed with scope resolution operator even if the function is virtual.
            </div>              
            </div>
            <hr />
            </LI>
            <!-- End of question 12 -->
					

          </OL>
        </div>

        <!-- wrap ends here; don't delete this /div --> 
        </div>

</div>
</div>

</body>
</html>

