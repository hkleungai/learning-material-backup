- {1=2, 2=3};
val it = (2,3) : int * int

- {1="2", 2="3"};
val it = ("2","3") : string * string

- hd(1);
Error
Remark: it can be hd([1]); .

- hd([]);
Error

- tl([]);
Error

- [1, 1.0];
Error

- [1 mod 2];
val it = [1] : int list

- "string"=("string");
val it = true : bool

- if 2=3 then {} else ();
val it = () : unit

- if 2=3 then {} else {1=2};
Error

- if 2=3 then () else (1,2);
Error

- if 2=3 then () else [1,2];
Error

- if 2=3 then [] else [1,2];
val it = [1,2] : int list

- if 2=3 then nil else [1,2];
val it = [1,2] : int list

- if 2=3 then (2) else {1=2};
Error
Remark: (2) -> val it = 2 : int, {1=2} -> val it = {1=2} : {1:int}.
SML does not have 1-tuple, {1=2} cannot be converted to (2). Therefore, the type of {1=2} is {1:int}.

- if 2=3 then (1,2) else {1=1, 2=2};
val it = (1,2) : int * int
Remark: according to the lecture notes 2, page 17:
Tuples are actually short-hands for records.
(E1, E2, E3) = { 1=E1, 2=E2, 3=E3 }
