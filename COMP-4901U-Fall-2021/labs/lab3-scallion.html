<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Lab 3 | clpcd</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Lab 3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Note: The Scallion Library" />
<meta property="og:description" content="Note: The Scallion Library" />
<meta property="og:site_name" content="clpcd" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Lab 3" />
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">Lab 3</h1>
      <h2 class="project-tagline">Note: The Scallion Library</h2>


        <a href="../index.html" class="btn">COMP 4901U Home</a>
        <a href="https://canvas.ust.hk/courses/38344" class="btn">COMP 4901U on Canvas</a>
    </header>

    <main id="content" class="main-content" role="main">
      <h1 id="introduction-to-parser-combinators">Introduction to Parser Combinators</h1>

<p>The next part of the compiler you will be working on is the parser. The goal of the parser is to convert the sequence of tokens generated by the lexer into an Amy <em>abstract syntax tree</em> (AST).
There are many approaches to writing parsers, such as:</p>

<ul>
  <li>
    <p>Writing the parser by hand directly in the compiler’s language using mutually recursive functions, or</p>
  </li>
  <li>
    <p>Writing the parser in a <em>domain specific language</em> (DSL) and using a parser generator (such as Bison) to produce the parser.</p>
  </li>
</ul>

<p>Another approach, which we will be using, is <em>parser combinators</em>. The idea behind the approach is very simple:</p>

<ul>
  <li>
    <p>Have a set of simple primitive parsers, and</p>
  </li>
  <li>
    <p>Have ways to combine them together into more and more complex parsers. Hence the name <em>parser combinators</em>.</p>
  </li>
</ul>

<p>Usually, those primitive parsers and combinators are provided as a library directly in the language used by the compiler. In our case, we will be working with <strong><a href="https://github.com/epfl-lara/scallion">Scallion</a></strong>, a Scala parser combinators library developed by the <em>LARA</em> lab at EPFL.
Parser combinators have many advantages – the main one being easy to write, read and maintain.</p>

<h1 id="scallion-parser-combinators-documentation">Scallion Parser Combinators Documentation</h1>

<p>In this document, we will introduce parser combinators in Scallion and showcase how to use them. This document is not intended to be a complete reference to Scallion. Fortunately, the library comes with a <a href="https://epfl-lara.github.io/scallion/scallion/index.html">comprehensive API</a> which fulfills that role. Feel free to refer to it while working on your project!</p>

<h2 id="playground-project">Playground Project</h2>

<p>We have set up <a href="https://lara.epfl.ch/w/_media/cc20/scallion-playground.zip">an example project</a> that implements a lexer and parser for a simple expression language using Scallion. Feel free to experiment and play with it. The project showcases the API of Scallion and some of the more advanced combinators.</p>

<h2 id="setup">Setup</h2>

<p>In Scallion, parsers are defined within a trait called <code class="language-plaintext highlighter-rouge">Syntaxes</code>. This trait takes as parameters two types:</p>

<ul>
  <li>
    <p>The type of tokens,</p>
  </li>
  <li>
    <p>The type of <em>token kinds</em>. Token kinds represent groups of tokens. They abstract away all the details found in the actual tokens, such as for instance positions or identifiers name. Each token has a unique kind.</p>
  </li>
</ul>

<p>In our case, the tokens will be of type <code class="language-plaintext highlighter-rouge">Token</code> that we introduced and used in the previous project. The token kinds will be <code class="language-plaintext highlighter-rouge">TokenKind</code>, which we have already defined for you.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Parser</span> <span class="k">extends</span> <span class="nc">Pipeline</span><span class="o">[</span><span class="kt">Iterator</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span>, <span class="kt">Program</span><span class="o">]</span>
                 <span class="k">with</span> <span class="nc">Parsers</span> <span class="o">{</span>

  <span class="k">type</span> <span class="kt">Token</span> <span class="o">=</span> <span class="nv">myproject</span><span class="o">.</span><span class="py">Token</span>
  <span class="k">type</span> <span class="kt">Kind</span> <span class="o">=</span> <span class="nv">myproject</span><span class="o">.</span><span class="py">TokenKind</span>

  <span class="c1">// Indicates the kind of the various tokens.</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">getKind</span><span class="o">(</span><span class="n">token</span><span class="k">:</span> <span class="kt">Token</span><span class="o">)</span><span class="k">:</span> <span class="kt">TokenKind</span> <span class="o">=</span> <span class="nv">TokenKind</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="n">token</span><span class="o">)</span>

  <span class="c1">// You parser implementation goes here.</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Parsers</code> trait (mixed into the <code class="language-plaintext highlighter-rouge">Parser</code> object above) comes from Scallion and provides all functions and types you will use to define your grammar and AST translation.</p>

<h2 id="writing-parsers">Writing Parsers</h2>

<p>When writing a parser using parser combinators, one defines many smaller parsers and combines them together into more and more complex parsers. The top-level, most complex, of those parser then defines the entire syntax for the language. In our case, that top-level parser will be called <code class="language-plaintext highlighter-rouge">program</code>.
All those parsers are objects of the type <code class="language-plaintext highlighter-rouge">Syntax[A]</code>. The type parameter <code class="language-plaintext highlighter-rouge">A</code> indicates the type of values produced by the parser. For instance, a parser of type <code class="language-plaintext highlighter-rouge">Syntax[Int]</code> produces <code class="language-plaintext highlighter-rouge">Int</code>s and a parser of type <code class="language-plaintext highlighter-rouge">Syntax[Expr]</code> produces <code class="language-plaintext highlighter-rouge">Expr</code>s. Our top-level parser has the following signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">program</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Program</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div></div>

<p>Contrary to the types of tokens and token kinds, which are fixed, the type of values produced is a type parameter of the various <code class="language-plaintext highlighter-rouge">Syntax</code>s. This allows your different parsers to produce different types of values.
The various parsers are stored as <code class="language-plaintext highlighter-rouge">val</code> members of the <code class="language-plaintext highlighter-rouge">Parser</code> object. In the case of mutually dependent parsers, we use <code class="language-plaintext highlighter-rouge">lazy val</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">definition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">functionDefinition</span> <span class="o">|</span> <span class="n">abstractClassDefinition</span> <span class="o">|</span> <span class="n">caseClassDefinition</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">functionDefinition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">abstractClassDefinition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">caseClassDefinition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div></div>

<h2 id="running-parsers">Running Parsers</h2>

<p>Parsers of type <code class="language-plaintext highlighter-rouge">Syntax[A]</code> can be converted to objects of type <code class="language-plaintext highlighter-rouge">Parser[A]</code>, which have an <code class="language-plaintext highlighter-rouge">apply</code> method which takes as parameter an iterator of tokens and returns a value of type <code class="language-plaintext highlighter-rouge">ParseResult[A]</code>, which can be one of three things:</p>

<ul>
  <li>
    <p>A <code class="language-plaintext highlighter-rouge">Parsed(value, rest)</code>, which indicates that the parser was successful and produced the value <code class="language-plaintext highlighter-rouge">value</code>. The entirety of the input iterator was consumed by the parser.</p>
  </li>
  <li>
    <p>An <code class="language-plaintext highlighter-rouge">UnexpectedToken(token, rest)</code>, which indicates that the parser encountered an unexpected token <code class="language-plaintext highlighter-rouge">token</code>. The input iterator was consumed up to the erroneous token.</p>
  </li>
  <li>
    <p>An <code class="language-plaintext highlighter-rouge">UnexpectedEnd(rest)</code>, which indicates that the end of the iterator was reached and the parser could not finish at this point. The input iterator was completely consumed.</p>
  </li>
</ul>

<p>In each case, the additional value <code class="language-plaintext highlighter-rouge">rest</code> is itself some sort of a <code class="language-plaintext highlighter-rouge">Parser[A]</code>. That parser represents the parser after the successful parse or at the point of error. This parser could be used to provide useful error messages or even to resume parsing.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">Context</span><span class="o">)(</span><span class="n">tokens</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Token</span><span class="o">])</span><span class="k">:</span> <span class="kt">Program</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">ctx.reporter._</span>

  <span class="k">val</span> <span class="nv">parser</span> <span class="k">=</span> <span class="nc">Parser</span><span class="o">(</span><span class="n">program</span><span class="o">)</span>

  <span class="nf">parser</span><span class="o">(</span><span class="n">tokens</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Parsed</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">result</span>
    <span class="k">case</span> <span class="nc">UnexpectedEnd</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">fatal</span><span class="o">(</span><span class="s">"Unexpected end of input."</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">UnexpectedToken</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">fatal</span><span class="o">(</span><span class="s">"Unexpected token: "</span> <span class="o">+</span> <span class="n">token</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="parsers-and-grammars">Parsers and Grammars</h2>

<p>As you will see, parsers built using parser combinators will look a lot like grammars. However, unlike grammars, parsers not only describe the syntax of your language, but also directly specify how to turn this syntax into a value. Also, as we will see, parser combinators have a richer vocabulary than your usual <em>BNF</em> grammars.
Interestingly, a lot of concepts that you have seen on grammars, such as <code class="language-plaintext highlighter-rouge">FIRST</code> sets and nullability can be straightforwardly transposed to parsers.</p>

<h3 id="first-set">FIRST set</h3>

<p>In Scallion, parsers offer a <code class="language-plaintext highlighter-rouge">first</code> method which returns the set of token kinds that are accepted as a first token.</p>

<p><code class="language-plaintext highlighter-rouge">definition.first === Set(def, abstract, case)</code></p>

<h3 id="nullability">Nullability</h3>

<p>Parsers have a <code class="language-plaintext highlighter-rouge">nullable</code> method which checks for nullability of a parser. The method returns <code class="language-plaintext highlighter-rouge">Some(value)</code> if the parser would produce <code class="language-plaintext highlighter-rouge">value</code> given an empty input token sequence, and <code class="language-plaintext highlighter-rouge">None</code> if the parser would not accept the empty sequence.</p>

<h2 id="basic-parsers">Basic Parsers</h2>

<p>We can now finally have a look at the toolbox we have at our disposition to build parsers, starting from the basic parsers. Each parser that you will write, however complex, is a combination of these basic parsers. The basic parsers play the same role as terminal symbols do in grammars.</p>

<h3 id="elem">Elem</h3>

<p>The first of the basic parsers is <code class="language-plaintext highlighter-rouge">elem(kind)</code>. The function <code class="language-plaintext highlighter-rouge">elem</code> takes argument the kind of tokens to be accepted by the parser. The value produced by the parser is the token that was matched. For instance, here is how to match against the <em>end-of-file</em> token.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">eof</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span> <span class="k">=</span> <span class="nf">elem</span><span class="o">(</span><span class="nc">EOFKind</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="accept">Accept</h3>

<p>The function <code class="language-plaintext highlighter-rouge">accept</code> is a variant of <code class="language-plaintext highlighter-rouge">elem</code> which directly applies a transformation to the matched token when it is produced.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">identifier</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">IdentifierKind</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">IdentifierToken</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">name</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="epsilon">Epsilon</h3>

<p>The parser <code class="language-plaintext highlighter-rouge">epsilon(value)</code> is a parser that produces the <code class="language-plaintext highlighter-rouge">value</code> without consuming any input. It corresponds to the <em>𝛆</em> found in grammars.</p>

<h2 id="parser-combinators">Parser Combinators</h2>

<p>In this section, we will see how to combine parsers together to create more complex parsers.</p>

<h3 id="disjunction">Disjunction</h3>

<p>The first combinator we have is disjunction, that we write, for parsers <code class="language-plaintext highlighter-rouge">p1</code> and <code class="language-plaintext highlighter-rouge">p2</code>, simply <code class="language-plaintext highlighter-rouge">p1 | p2</code>. When both <code class="language-plaintext highlighter-rouge">p1</code> and <code class="language-plaintext highlighter-rouge">p2</code> are of type <code class="language-plaintext highlighter-rouge">Syntax[A]</code>, the disjunction <code class="language-plaintext highlighter-rouge">p1 | p2</code> is also of type <code class="language-plaintext highlighter-rouge">Syntax[A]</code>. The disjunction operator is associative and commutative.
Disjunction works just as you think it does. If either of the parsers <code class="language-plaintext highlighter-rouge">p1</code> or <code class="language-plaintext highlighter-rouge">p2</code> would accept the sequence of tokens, then the disjunction also accepts the tokens. The value produced is the one produced by either <code class="language-plaintext highlighter-rouge">p1</code> or <code class="language-plaintext highlighter-rouge">p2</code>.
Note that <code class="language-plaintext highlighter-rouge">p1</code> and <code class="language-plaintext highlighter-rouge">p2</code> must have disjoint <code class="language-plaintext highlighter-rouge">first</code> sets. This restriction ensures that no ambiguities can arise and that parsing can be done efficiently.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> We will see later how to automatically detect when this is not the case and how fix the issue.</p>

<h3 id="sequencing">Sequencing</h3>

<p>The second combinator we have is sequencing. We write, for parsers <code class="language-plaintext highlighter-rouge">p1</code> and <code class="language-plaintext highlighter-rouge">p2</code>, the sequence of <code class="language-plaintext highlighter-rouge">p1</code> and <code class="language-plaintext highlighter-rouge">p2</code> as <code class="language-plaintext highlighter-rouge">p1 ~ p2</code>. When <code class="language-plaintext highlighter-rouge">p1</code> is of type <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">p2</code> of type <code class="language-plaintext highlighter-rouge">B</code>, their sequence is of type <code class="language-plaintext highlighter-rouge">A ~ B</code>, which is simply a pair of an <code class="language-plaintext highlighter-rouge">A</code> and a <code class="language-plaintext highlighter-rouge">B</code>.
If the parser <code class="language-plaintext highlighter-rouge">p1</code> accepts the prefix of a sequence of tokens and <code class="language-plaintext highlighter-rouge">p2</code> accepts the postfix, the parser <code class="language-plaintext highlighter-rouge">p1 ~ p2</code> accepts the entire sequence and produces the pair of values produced by <code class="language-plaintext highlighter-rouge">p1</code> and <code class="language-plaintext highlighter-rouge">p2</code>.
Note that the <code class="language-plaintext highlighter-rouge">first</code> set of <code class="language-plaintext highlighter-rouge">p2</code> should be disjoint from the <code class="language-plaintext highlighter-rouge">first</code> set of all sub-parsers in <code class="language-plaintext highlighter-rouge">p1</code> that are <em>nullable</em> and in trailing position (available via the <code class="language-plaintext highlighter-rouge">followLast</code> method). This restriction ensures that the combinator does not introduce ambiguities.</p>

<h3 id="transforming-values">Transforming Values</h3>

<p>The method <code class="language-plaintext highlighter-rouge">map</code> makes it possible to apply a transformation to the values produced by a parser. Using <code class="language-plaintext highlighter-rouge">map</code> does not influence the sequence of tokens accepted or rejected by the parser, it merely modifies the value produced. Generally, you will use <code class="language-plaintext highlighter-rouge">map</code> on a sequence of parsers, as in:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">abstractClassDefinition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nf">kw</span><span class="o">(</span><span class="s">"abstract"</span><span class="o">)</span> <span class="o">~</span> <span class="nf">kw</span><span class="o">(</span><span class="s">"class"</span><span class="o">)</span> <span class="o">~</span> <span class="n">identifier</span><span class="o">).</span><span class="py">map</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">kw</span> <span class="o">~</span> <span class="k">_</span> <span class="o">~</span> <span class="n">id</span> <span class="k">=&gt;</span> <span class="nc">AbstractClassDef</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="py">setPos</span><span class="o">(</span><span class="n">kw</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The above parser accepts abstract class definitions in Amy syntax. It does so by accepting the sequence of keywords <code class="language-plaintext highlighter-rouge">abstract</code> and <code class="language-plaintext highlighter-rouge">class</code>, followed by any identifier. The method <code class="language-plaintext highlighter-rouge">map</code> is used to convert the produced values into an <code class="language-plaintext highlighter-rouge">AbstractClassDef</code>. The position of the keyword <code class="language-plaintext highlighter-rouge">abstract</code> is used as the position of the definition.</p>

<h3 id="recursive-parsers">Recursive Parsers</h3>

<p>It is highly likely that some of your parsers will require to recursively invoke themselves. In this case, you should indicate that the parser is recursive using the <code class="language-plaintext highlighter-rouge">recursive</code> combinator:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">expr</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">Expr</span><span class="o">]</span> <span class="k">=</span> <span class="n">recursive</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If you were to omit it, a <code class="language-plaintext highlighter-rouge">StackOverflow</code> exception would be triggered during the initialisation of your <code class="language-plaintext highlighter-rouge">Parser</code> object.
The <code class="language-plaintext highlighter-rouge">recursive</code> combinator in itself does not change the behaviour of the underlying parser. It is there to <em>tie the knot</em><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.
In practice, it is only required in very few places. In order to avoid <code class="language-plaintext highlighter-rouge">StackOverflow</code> exceptions during initialisation, you should make sure that all recursive parsers (stored in <code class="language-plaintext highlighter-rouge">lazy val</code>s) must not be able to reenter themselves without going through a <code class="language-plaintext highlighter-rouge">recursive</code> combinator somewhere along the way.</p>

<h3 id="other-combinators">Other Combinators</h3>

<p>So far, many of the combinators that we have seen, such as disjunction and sequencing, directly correspond to constructs found in <code class="language-plaintext highlighter-rouge">BNF</code> grammars. Some of the combinators that we will see now are more expressive and implement useful patterns.</p>

<h4 id="optional-parsers-using-opt">Optional parsers using opt</h4>

<p>The combinator <code class="language-plaintext highlighter-rouge">opt</code> makes a parser optional. The value produced by the parser is wrapped in <code class="language-plaintext highlighter-rouge">Some</code> if the parser accepts the input sequence and in <code class="language-plaintext highlighter-rouge">None</code> otherwise.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">opt</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">===</span> <span class="nv">p</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="o">|</span> <span class="nf">epsilon</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="repetitions-using-many-and-many1">Repetitions using many and many1</h4>

<p>The combinator <code class="language-plaintext highlighter-rouge">many</code> returns a parser that accepts any number of repetitions of its argument parser, including 0. The variant <code class="language-plaintext highlighter-rouge">many1</code> forces the parser to match at least once.</p>

<h4 id="repetitions-with-separators-repsep-and-rep1sep">Repetitions with separators repsep and rep1sep</h4>

<p>The combinator <code class="language-plaintext highlighter-rouge">repsep</code> returns a parser that accepts any number of repetitions of its argument parser, separated by an other parser, including 0. The variant <code class="language-plaintext highlighter-rouge">rep1sep</code> forces the parser to match at least once.
The separator parser is restricted to the type <code class="language-plaintext highlighter-rouge">Syntax[Unit]</code> to ensure that important values do not get ignored. You may use <code class="language-plaintext highlighter-rouge">unit()</code> to on a parser to turn its value to <code class="language-plaintext highlighter-rouge">Unit</code> if you explicitly want to ignore the values a parser produces.</p>

<h4 id="binary-operators-with-operators">Binary operators with operators</h4>

<p>Scallion also contains combinators to easily build parsers for infix binary operators, with different associativities and priority levels. This combinator is defined in an additional trait called <code class="language-plaintext highlighter-rouge">Operators</code>, which you should mix into <code class="language-plaintext highlighter-rouge">Parsers</code> if you want to use the combinator. By default, it should already be mixed-in.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">times</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">accept</span><span class="o">(</span><span class="nc">OperatorKind</span><span class="o">(</span><span class="s">"*"</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"*"</span>
  <span class="o">}</span>

<span class="o">...</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">operation</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">Expr</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">operators</span><span class="o">(</span><span class="n">number</span><span class="o">)(</span>
    <span class="c1">// Defines the different operators, by decreasing priority.</span>
    <span class="n">times</span> <span class="o">|</span> <span class="n">div</span>   <span class="n">is</span> <span class="nc">LeftAssociative</span><span class="o">,</span>
    <span class="n">plus</span>  <span class="o">|</span> <span class="n">minus</span> <span class="n">is</span> <span class="nc">LeftAssociative</span><span class="o">,</span>
    <span class="o">...</span>
  <span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Defines how to apply the various operators.</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="s">"*"</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Times</span><span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">).</span><span class="py">setPos</span><span class="o">(</span><span class="n">lhs</span><span class="o">)</span>
    <span class="o">...</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Documentation for <code class="language-plaintext highlighter-rouge">operators</code> is <a href="https://epfl-lara.github.io/scallion/scallion/Operators.html">available on this page</a>.</p>

<h4 id="upcasting">Upcasting</h4>

<p>In Scallion, the type <code class="language-plaintext highlighter-rouge">Syntax[A]</code> is invariant with <code class="language-plaintext highlighter-rouge">A</code>, meaning that, even when <code class="language-plaintext highlighter-rouge">A</code> is a (strict) subtype of some type <code class="language-plaintext highlighter-rouge">B</code>, we <em>won’t</em> have that <code class="language-plaintext highlighter-rouge">Syntax[A]</code> is a subtype of <code class="language-plaintext highlighter-rouge">Syntax[B]</code>. To upcast a <code class="language-plaintext highlighter-rouge">Syntax[A]</code> to a syntax <code class="language-plaintext highlighter-rouge">Syntax[B]</code> (when <code class="language-plaintext highlighter-rouge">A</code> is a subtype of <code class="language-plaintext highlighter-rouge">B</code>), you should use the <code class="language-plaintext highlighter-rouge">.up[B]</code> method.
For instance, you may need to upcast a syntax of type <code class="language-plaintext highlighter-rouge">Syntax[Literal[_]]</code> to a <code class="language-plaintext highlighter-rouge">Syntax[Expr]</code> in your assignment. To do so, simply use <code class="language-plaintext highlighter-rouge">.up[Expr]</code>.</p>

<h2 id="ll1-checking">LL(1) Checking</h2>

<p>In Scallion, non-LL(1) parsers can be written, but the result of applying such a parser is not specified. In practice, we therefore restrict ourselves only to LL(1) parsers. The reason behind this is that LL(1) parsers are unambiguous and can be run in time linear in the input size.
Writing LL(1) parsers is non-trivial. However, some of the higher-level combinators of Scallion already alleviate part of this pain. In addition, LL(1) violations can be detected before the parser is run. Syntaxes have an <code class="language-plaintext highlighter-rouge">isLL1</code> method which returns <code class="language-plaintext highlighter-rouge">true</code> if the parser is LL(1) and <code class="language-plaintext highlighter-rouge">false</code> otherwise, and so without needing to see any tokens of input.</p>

<h3 id="conflict-witnesses">Conflict Witnesses</h3>

<p>In case your parser is not LL(1), the method <code class="language-plaintext highlighter-rouge">conflicts</code> of the parser will return the set of all <code class="language-plaintext highlighter-rouge">LL1Conflict</code>s. The various conflicts are:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NullableConflict</code>, which indicates that two branches of a disjunction are nullable.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FirstConflict</code>, which indicates that the <code class="language-plaintext highlighter-rouge">first</code> set of two branches of a disjunction are not disjoint.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FollowConflict</code>, which indicates that the <code class="language-plaintext highlighter-rouge">first</code> set of a nullable parser is not disjoint from the <code class="language-plaintext highlighter-rouge">first</code> set of a parser that directly follows it.</p>
  </li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">LL1Conflict</code>s objects contain fields which can help you pinpoint the exact location of conflicts in your parser and hopefully help you fix those.
The helper method <code class="language-plaintext highlighter-rouge">debug</code> prints a summary of the LL(1) conflicts of a parser. We added code in the handout skeleton so that, by default, a report is outputted in case of conflicts when you initialise your parser.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Scallion is not the only parser combinator library to exist, far from it! Many of those libraries do not have this restriction. Those libraries generally need to backtrack to try the different alternatives when a branch fails. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>See <a href="https://stackoverflow.com/questions/357956/explanation-of-tying-the-knot">a good explanation of what tying the knot means in the context of lazy languages.</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>
