<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Lab 3 | clpcd</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Lab 3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Note: The Scallion Library" />
<meta property="og:description" content="Note: The Scallion Library" />
<meta property="og:site_name" content="clpcd" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Lab 3" />
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">Lab 3</h1>
      <h2 class="project-tagline">Note: The Scallion Library</h2>


        <a href="../index.html" class="btn">COMP 4901U Home</a>
        <a href="https://canvas.ust.hk/courses/38344" class="btn">COMP 4901U on Canvas</a>
    </header>

    <main id="content" class="main-content" role="main">
      <h1 id="introduction-to-parser-combinators">Introduction to Parser Combinators</h1>

<p>The next part of the compiler you will be working on is the parser. The goal of the parser is to convert the sequence of tokens generated by the lexer into an AmyÂ <em>abstract syntax tree</em>Â (AST).
There are many approaches to writing parsers, such as:</p>

<ul>
  <li>
    <p>Writing the parser by hand directly in the compilerâ€™s language using mutually recursive functions, or</p>
  </li>
  <li>
    <p>Writing the parser in aÂ <em>domain specific language</em>Â (DSL) and using a parser generator (such as Bison) to produce the parser.</p>
  </li>
</ul>

<p>Another approach, which we will be using, isÂ <em>parser combinators</em>. The idea behind the approach is very simple:</p>

<ul>
  <li>
    <p>Have a set of simple primitive parsers, and</p>
  </li>
  <li>
    <p>Have ways to combine them together into more and more complex parsers. Hence the nameÂ <em>parser combinators</em>.</p>
  </li>
</ul>

<p>Usually, those primitive parsers and combinators are provided as a library directly in the language used by the compiler. In our case, we will be working withÂ <strong><a href="https://github.com/epfl-lara/scallion">Scallion</a></strong>, a Scala parser combinators library developed byÂ the <em>LARA</em> lab at EPFL.
Parser combinators have many advantages â€“ the main one being easy to write, read and maintain.</p>

<h1 id="scallion-parser-combinators-documentation">Scallion Parser Combinators Documentation</h1>

<p>In this document, we will introduce parser combinators in Scallion and showcase how to use them. This document is not intended to be a complete reference to Scallion. Fortunately, the library comes with aÂ <a href="https://epfl-lara.github.io/scallion/scallion/index.html">comprehensive API</a>Â which fulfills that role. Feel free to refer to it while working on your project!</p>

<h2 id="playground-project">Playground Project</h2>

<p>We have set upÂ <a href="https://lara.epfl.ch/w/_media/cc20/scallion-playground.zip">an example project</a>Â that implements a lexer and parser for a simple expression language using Scallion. Feel free to experiment and play with it. The project showcases theÂ APIÂ of Scallion and some of the more advanced combinators.</p>

<h2 id="setup">Setup</h2>

<p>In Scallion, parsers are defined within a trait calledÂ <code class="language-plaintext highlighter-rouge">Syntaxes</code>. This trait takes as parameters two types:</p>

<ul>
  <li>
    <p>The type of tokens,</p>
  </li>
  <li>
    <p>The type ofÂ <em>token kinds</em>. Token kinds represent groups of tokens. They abstract away all the details found in the actual tokens, such as for instance positions or identifiers name. Each token has a unique kind.</p>
  </li>
</ul>

<p>In our case, the tokens will be of typeÂ <code class="language-plaintext highlighter-rouge">Token</code>Â that we introduced and used in the previous project. The token kinds will beÂ <code class="language-plaintext highlighter-rouge">TokenKind</code>, which we have already defined for you.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Parser</span> <span class="k">extends</span> <span class="nc">Pipeline</span><span class="o">[</span><span class="kt">Iterator</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span>, <span class="kt">Program</span><span class="o">]</span>
                 <span class="k">with</span> <span class="nc">Parsers</span> <span class="o">{</span>

  <span class="k">type</span> <span class="kt">Token</span> <span class="o">=</span> <span class="nv">myproject</span><span class="o">.</span><span class="py">Token</span>
  <span class="k">type</span> <span class="kt">Kind</span> <span class="o">=</span> <span class="nv">myproject</span><span class="o">.</span><span class="py">TokenKind</span>

  <span class="c1">// Indicates the kind of the various tokens.</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">getKind</span><span class="o">(</span><span class="n">token</span><span class="k">:</span> <span class="kt">Token</span><span class="o">)</span><span class="k">:</span> <span class="kt">TokenKind</span> <span class="o">=</span> <span class="nv">TokenKind</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="n">token</span><span class="o">)</span>

  <span class="c1">// You parser implementation goes here.</span>
<span class="o">}</span>
</code></pre></div></div>

<p>TheÂ <code class="language-plaintext highlighter-rouge">Parsers</code>Â trait (mixed into theÂ <code class="language-plaintext highlighter-rouge">Parser</code>Â object above) comes from Scallion and provides all functions and types you will use to define your grammar and AST translation.</p>

<h2 id="writing-parsers">Writing Parsers</h2>

<p>When writing a parser using parser combinators, one defines many smaller parsers and combines them together into more and more complex parsers. The top-level, most complex, of those parser then defines the entire syntax for the language. In our case, that top-level parser will be calledÂ <code class="language-plaintext highlighter-rouge">program</code>.
All those parsers are objects of the typeÂ <code class="language-plaintext highlighter-rouge">Syntax[A]</code>. The type parameterÂ <code class="language-plaintext highlighter-rouge">A</code>Â indicates the type of values produced by the parser. For instance, a parser of typeÂ <code class="language-plaintext highlighter-rouge">Syntax[Int]</code>Â producesÂ <code class="language-plaintext highlighter-rouge">Int</code>s and a parser of typeÂ <code class="language-plaintext highlighter-rouge">Syntax[Expr]</code>Â producesÂ <code class="language-plaintext highlighter-rouge">Expr</code>s. Our top-level parser has the following signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">program</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Program</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div></div>

<p>Contrary to the types of tokens and token kinds, which are fixed, the type of values produced is a type parameter of the variousÂ <code class="language-plaintext highlighter-rouge">Syntax</code>s. This allows your different parsers to produce different types of values.
The various parsers are stored asÂ <code class="language-plaintext highlighter-rouge">val</code>Â members of theÂ <code class="language-plaintext highlighter-rouge">Parser</code>Â object. In the case of mutually dependent parsers, we useÂ <code class="language-plaintext highlighter-rouge">lazy val</code>Â instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">definition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">functionDefinition</span> <span class="o">|</span> <span class="n">abstractClassDefinition</span> <span class="o">|</span> <span class="n">caseClassDefinition</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">functionDefinition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">abstractClassDefinition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">caseClassDefinition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div></div>

<h2 id="running-parsers">Running Parsers</h2>

<p>Parsers of typeÂ <code class="language-plaintext highlighter-rouge">Syntax[A]</code>Â can be converted to objects of typeÂ <code class="language-plaintext highlighter-rouge">Parser[A]</code>, which have anÂ <code class="language-plaintext highlighter-rouge">apply</code>Â method which takes as parameter an iterator of tokens and returns a value of typeÂ <code class="language-plaintext highlighter-rouge">ParseResult[A]</code>, which can be one of three things:</p>

<ul>
  <li>
    <p>AÂ <code class="language-plaintext highlighter-rouge">Parsed(value, rest)</code>, which indicates that the parser was successful and produced the valueÂ <code class="language-plaintext highlighter-rouge">value</code>. The entirety of the input iterator was consumed by the parser.</p>
  </li>
  <li>
    <p>AnÂ <code class="language-plaintext highlighter-rouge">UnexpectedToken(token, rest)</code>, which indicates that the parser encountered an unexpected tokenÂ <code class="language-plaintext highlighter-rouge">token</code>. The input iterator was consumed up to the erroneous token.</p>
  </li>
  <li>
    <p>AnÂ <code class="language-plaintext highlighter-rouge">UnexpectedEnd(rest)</code>, which indicates that the end of the iterator was reached and the parser could not finish at this point. The input iterator was completely consumed.</p>
  </li>
</ul>

<p>In each case, the additional valueÂ <code class="language-plaintext highlighter-rouge">rest</code>Â is itself some sort of aÂ <code class="language-plaintext highlighter-rouge">Parser[A]</code>. That parser represents the parser after the successful parse or at the point of error. This parser could be used to provide useful error messages or even to resume parsing.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">Context</span><span class="o">)(</span><span class="n">tokens</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Token</span><span class="o">])</span><span class="k">:</span> <span class="kt">Program</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">ctx.reporter._</span>

  <span class="k">val</span> <span class="nv">parser</span> <span class="k">=</span> <span class="nc">Parser</span><span class="o">(</span><span class="n">program</span><span class="o">)</span>

  <span class="nf">parser</span><span class="o">(</span><span class="n">tokens</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Parsed</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">result</span>
    <span class="k">case</span> <span class="nc">UnexpectedEnd</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">fatal</span><span class="o">(</span><span class="s">"Unexpected end of input."</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">UnexpectedToken</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">fatal</span><span class="o">(</span><span class="s">"Unexpected token: "</span> <span class="o">+</span> <span class="n">token</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="parsers-and-grammars">Parsers and Grammars</h2>

<p>As you will see, parsers built using parser combinators will look a lot like grammars. However, unlike grammars, parsers not only describe the syntax of your language, but also directly specify how to turn this syntax into a value. Also, as we will see, parser combinators have a richer vocabulary than your usualÂ <em>BNF</em>Â grammars.
Interestingly, a lot of concepts that you have seen on grammars, such asÂ <code class="language-plaintext highlighter-rouge">FIRST</code>Â sets and nullability can be straightforwardly transposed to parsers.</p>

<h3 id="first-set">FIRST set</h3>

<p>In Scallion, parsers offer aÂ <code class="language-plaintext highlighter-rouge">first</code>Â method which returns the set of token kinds that are accepted as a first token.</p>

<p><code class="language-plaintext highlighter-rouge">definition.first === Set(def, abstract, case)</code></p>

<h3 id="nullability">Nullability</h3>

<p>Parsers have aÂ <code class="language-plaintext highlighter-rouge">nullable</code>Â method which checks for nullability of a parser. The method returnsÂ <code class="language-plaintext highlighter-rouge">Some(value)</code>Â if the parser would produceÂ <code class="language-plaintext highlighter-rouge">value</code>Â given an empty input token sequence, andÂ <code class="language-plaintext highlighter-rouge">None</code>Â if the parser would not accept the empty sequence.</p>

<h2 id="basic-parsers">Basic Parsers</h2>

<p>We can now finally have a look at the toolbox we have at our disposition to build parsers, starting from the basic parsers. Each parser that you will write, however complex, is a combination of these basic parsers. The basic parsers play the same role as terminal symbols do in grammars.</p>

<h3 id="elem">Elem</h3>

<p>The first of the basic parsers isÂ <code class="language-plaintext highlighter-rouge">elem(kind)</code>. The functionÂ <code class="language-plaintext highlighter-rouge">elem</code>Â takes argument the kind of tokens to be accepted by the parser. The value produced by the parser is the token that was matched. For instance, here is how to match against theÂ <em>end-of-file</em>Â token.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">eof</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span> <span class="k">=</span> <span class="nf">elem</span><span class="o">(</span><span class="nc">EOFKind</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="accept">Accept</h3>

<p>The functionÂ <code class="language-plaintext highlighter-rouge">accept</code>Â is a variant ofÂ <code class="language-plaintext highlighter-rouge">elem</code>Â which directly applies a transformation to the matched token when it is produced.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">identifier</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">IdentifierKind</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">IdentifierToken</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">name</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="epsilon">Epsilon</h3>

<p>The parserÂ <code class="language-plaintext highlighter-rouge">epsilon(value)</code>Â is a parser that produces theÂ <code class="language-plaintext highlighter-rouge">value</code>Â without consuming any input. It corresponds to theÂ <em>ğ›†</em>Â found in grammars.</p>

<h2 id="parser-combinators">Parser Combinators</h2>

<p>In this section, we will see how to combine parsers together to create more complex parsers.</p>

<h3 id="disjunction">Disjunction</h3>

<p>The first combinator we have is disjunction, that we write, for parsersÂ <code class="language-plaintext highlighter-rouge">p1</code>Â andÂ <code class="language-plaintext highlighter-rouge">p2</code>, simplyÂ <code class="language-plaintext highlighter-rouge">p1 | p2</code>. When bothÂ <code class="language-plaintext highlighter-rouge">p1</code>Â andÂ <code class="language-plaintext highlighter-rouge">p2</code>Â are of typeÂ <code class="language-plaintext highlighter-rouge">Syntax[A]</code>, the disjunctionÂ <code class="language-plaintext highlighter-rouge">p1 | p2</code>Â is also of typeÂ <code class="language-plaintext highlighter-rouge">Syntax[A]</code>. The disjunction operator is associative and commutative.
Disjunction works just as you think it does. If either of the parsersÂ <code class="language-plaintext highlighter-rouge">p1</code>Â orÂ <code class="language-plaintext highlighter-rouge">p2</code>Â would accept the sequence of tokens, then the disjunction also accepts the tokens. The value produced is the one produced by eitherÂ <code class="language-plaintext highlighter-rouge">p1</code>Â orÂ <code class="language-plaintext highlighter-rouge">p2</code>.
Note thatÂ <code class="language-plaintext highlighter-rouge">p1</code>Â andÂ <code class="language-plaintext highlighter-rouge">p2</code>Â must have disjointÂ <code class="language-plaintext highlighter-rouge">first</code>Â sets. This restriction ensures that no ambiguities can arise and that parsing can be done efficiently.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>Â We will see later how to automatically detect when this is not the case and how fix the issue.</p>

<h3 id="sequencing">Sequencing</h3>

<p>The second combinator we have is sequencing. We write, for parsersÂ <code class="language-plaintext highlighter-rouge">p1</code>Â andÂ <code class="language-plaintext highlighter-rouge">p2</code>, the sequence ofÂ <code class="language-plaintext highlighter-rouge">p1</code>Â andÂ <code class="language-plaintext highlighter-rouge">p2</code>Â asÂ <code class="language-plaintext highlighter-rouge">p1 ~ p2</code>. WhenÂ <code class="language-plaintext highlighter-rouge">p1</code>Â is of typeÂ <code class="language-plaintext highlighter-rouge">A</code>Â andÂ <code class="language-plaintext highlighter-rouge">p2</code>Â of typeÂ <code class="language-plaintext highlighter-rouge">B</code>, their sequence is of typeÂ <code class="language-plaintext highlighter-rouge">A ~ B</code>, which is simply a pair of anÂ <code class="language-plaintext highlighter-rouge">A</code>Â and aÂ <code class="language-plaintext highlighter-rouge">B</code>.
If the parserÂ <code class="language-plaintext highlighter-rouge">p1</code>Â accepts the prefix of a sequence of tokens andÂ <code class="language-plaintext highlighter-rouge">p2</code>Â accepts the postfix, the parserÂ <code class="language-plaintext highlighter-rouge">p1 ~ p2</code>Â accepts the entire sequence and produces the pair of values produced byÂ <code class="language-plaintext highlighter-rouge">p1</code>Â andÂ <code class="language-plaintext highlighter-rouge">p2</code>.
Note that theÂ <code class="language-plaintext highlighter-rouge">first</code>Â set ofÂ <code class="language-plaintext highlighter-rouge">p2</code>Â should be disjoint from theÂ <code class="language-plaintext highlighter-rouge">first</code>Â set of all sub-parsers inÂ <code class="language-plaintext highlighter-rouge">p1</code>Â that areÂ <em>nullable</em>Â and in trailing position (available via theÂ <code class="language-plaintext highlighter-rouge">followLast</code>Â method). This restriction ensures that the combinator does not introduce ambiguities.</p>

<h3 id="transforming-values">Transforming Values</h3>

<p>The methodÂ <code class="language-plaintext highlighter-rouge">map</code>Â makes it possible to apply a transformation to the values produced by a parser. UsingÂ <code class="language-plaintext highlighter-rouge">map</code>Â does not influence the sequence of tokens accepted or rejected by the parser, it merely modifies the value produced. Generally, you will useÂ <code class="language-plaintext highlighter-rouge">map</code>Â on a sequence of parsers, as in:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">abstractClassDefinition</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">ClassOrFunDef</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nf">kw</span><span class="o">(</span><span class="s">"abstract"</span><span class="o">)</span> <span class="o">~</span> <span class="nf">kw</span><span class="o">(</span><span class="s">"class"</span><span class="o">)</span> <span class="o">~</span> <span class="n">identifier</span><span class="o">).</span><span class="py">map</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">kw</span> <span class="o">~</span> <span class="k">_</span> <span class="o">~</span> <span class="n">id</span> <span class="k">=&gt;</span> <span class="nc">AbstractClassDef</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="py">setPos</span><span class="o">(</span><span class="n">kw</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The above parser accepts abstract class definitions in Amy syntax. It does so by accepting the sequence of keywordsÂ <code class="language-plaintext highlighter-rouge">abstract</code>Â andÂ <code class="language-plaintext highlighter-rouge">class</code>, followed by any identifier. The methodÂ <code class="language-plaintext highlighter-rouge">map</code>Â is used to convert the produced values into anÂ <code class="language-plaintext highlighter-rouge">AbstractClassDef</code>. The position of the keywordÂ <code class="language-plaintext highlighter-rouge">abstract</code>Â is used as the position of the definition.</p>

<h3 id="recursive-parsers">Recursive Parsers</h3>

<p>It is highly likely that some of your parsers will require to recursively invoke themselves. In this case, you should indicate that the parser is recursive using theÂ <code class="language-plaintext highlighter-rouge">recursive</code>Â combinator:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">expr</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">Expr</span><span class="o">]</span> <span class="k">=</span> <span class="n">recursive</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If you were to omit it, aÂ <code class="language-plaintext highlighter-rouge">StackOverflow</code>Â exception would be triggered during the initialisation of yourÂ <code class="language-plaintext highlighter-rouge">Parser</code>Â object.
TheÂ <code class="language-plaintext highlighter-rouge">recursive</code>Â combinator in itself does not change the behaviour of the underlying parser. It is there toÂ <em>tie the knot</em><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.
In practice, it is only required in very few places. In order to avoidÂ <code class="language-plaintext highlighter-rouge">StackOverflow</code>Â exceptions during initialisation, you should make sure that all recursive parsers (stored inÂ <code class="language-plaintext highlighter-rouge">lazy val</code>s) must not be able to reenter themselves without going through aÂ <code class="language-plaintext highlighter-rouge">recursive</code>Â combinator somewhere along the way.</p>

<h3 id="other-combinators">Other Combinators</h3>

<p>So far, many of the combinators that we have seen, such as disjunction and sequencing, directly correspond to constructs found inÂ <code class="language-plaintext highlighter-rouge">BNF</code>Â grammars. Some of the combinators that we will see now are more expressive and implement useful patterns.</p>

<h4 id="optional-parsers-using-opt">Optional parsers using opt</h4>

<p>The combinatorÂ <code class="language-plaintext highlighter-rouge">opt</code>Â makes a parser optional. The value produced by the parser is wrapped inÂ <code class="language-plaintext highlighter-rouge">Some</code>Â if the parser accepts the input sequence and inÂ <code class="language-plaintext highlighter-rouge">None</code>Â otherwise.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">opt</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">===</span> <span class="nv">p</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="o">|</span> <span class="nf">epsilon</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="repetitions-using-many-and-many1">Repetitions using many and many1</h4>

<p>The combinatorÂ <code class="language-plaintext highlighter-rouge">many</code>Â returns a parser that accepts any number of repetitions of its argument parser, including 0. The variantÂ <code class="language-plaintext highlighter-rouge">many1</code>Â forces the parser to match at least once.</p>

<h4 id="repetitions-with-separators-repsep-and-rep1sep">Repetitions with separators repsep and rep1sep</h4>

<p>The combinatorÂ <code class="language-plaintext highlighter-rouge">repsep</code>Â returns a parser that accepts any number of repetitions of its argument parser, separated by an other parser, including 0. The variantÂ <code class="language-plaintext highlighter-rouge">rep1sep</code>Â forces the parser to match at least once.
The separator parser is restricted to the typeÂ <code class="language-plaintext highlighter-rouge">Syntax[Unit]</code>Â to ensure that important values do not get ignored. You may useÂ <code class="language-plaintext highlighter-rouge">unit()</code>Â to on a parser to turn its value toÂ <code class="language-plaintext highlighter-rouge">Unit</code>Â if you explicitly want to ignore the values a parser produces.</p>

<h4 id="binary-operators-with-operators">Binary operators with operators</h4>

<p>Scallion also contains combinators to easily build parsers for infix binary operators, with different associativities and priority levels. This combinator is defined in an additional trait calledÂ <code class="language-plaintext highlighter-rouge">Operators</code>, which you should mix intoÂ <code class="language-plaintext highlighter-rouge">Parsers</code>Â if you want to use the combinator. By default, it should already be mixed-in.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">times</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">accept</span><span class="o">(</span><span class="nc">OperatorKind</span><span class="o">(</span><span class="s">"*"</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"*"</span>
  <span class="o">}</span>

<span class="o">...</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">operation</span><span class="k">:</span> <span class="kt">Syntax</span><span class="o">[</span><span class="kt">Expr</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">operators</span><span class="o">(</span><span class="n">number</span><span class="o">)(</span>
    <span class="c1">// Defines the different operators, by decreasing priority.</span>
    <span class="n">times</span> <span class="o">|</span> <span class="n">div</span>   <span class="n">is</span> <span class="nc">LeftAssociative</span><span class="o">,</span>
    <span class="n">plus</span>  <span class="o">|</span> <span class="n">minus</span> <span class="n">is</span> <span class="nc">LeftAssociative</span><span class="o">,</span>
    <span class="o">...</span>
  <span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Defines how to apply the various operators.</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="s">"*"</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Times</span><span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">).</span><span class="py">setPos</span><span class="o">(</span><span class="n">lhs</span><span class="o">)</span>
    <span class="o">...</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Documentation forÂ <code class="language-plaintext highlighter-rouge">operators</code>Â isÂ <a href="https://epfl-lara.github.io/scallion/scallion/Operators.html">available on this page</a>.</p>

<h4 id="upcasting">Upcasting</h4>

<p>In Scallion, the typeÂ <code class="language-plaintext highlighter-rouge">Syntax[A]</code>Â is invariant withÂ <code class="language-plaintext highlighter-rouge">A</code>, meaning that, even whenÂ <code class="language-plaintext highlighter-rouge">A</code>Â is a (strict) subtype of some typeÂ <code class="language-plaintext highlighter-rouge">B</code>, weÂ <em>wonâ€™t</em>Â have thatÂ <code class="language-plaintext highlighter-rouge">Syntax[A]</code>Â is a subtype ofÂ <code class="language-plaintext highlighter-rouge">Syntax[B]</code>. To upcast aÂ <code class="language-plaintext highlighter-rouge">Syntax[A]</code>Â to a syntaxÂ <code class="language-plaintext highlighter-rouge">Syntax[B]</code>Â (whenÂ <code class="language-plaintext highlighter-rouge">A</code>Â is a subtype ofÂ <code class="language-plaintext highlighter-rouge">B</code>), you should use theÂ <code class="language-plaintext highlighter-rouge">.up[B]</code>Â method.
For instance, you may need to upcast a syntax of typeÂ <code class="language-plaintext highlighter-rouge">Syntax[Literal[_]]</code>Â to aÂ <code class="language-plaintext highlighter-rouge">Syntax[Expr]</code>Â in your assignment. To do so, simply useÂ <code class="language-plaintext highlighter-rouge">.up[Expr]</code>.</p>

<h2 id="ll1-checking">LL(1) Checking</h2>

<p>In Scallion, non-LL(1) parsers can be written, but the result of applying such a parser is not specified. In practice, we therefore restrict ourselves only to LL(1) parsers. The reason behind this is that LL(1) parsers are unambiguous and can be run in time linear in the input size.
Writing LL(1) parsers is non-trivial. However, some of the higher-level combinators of Scallion already alleviate part of this pain. In addition, LL(1) violations can be detected before the parser is run. Syntaxes have anÂ <code class="language-plaintext highlighter-rouge">isLL1</code>Â method which returnsÂ <code class="language-plaintext highlighter-rouge">true</code>Â if the parser is LL(1) andÂ <code class="language-plaintext highlighter-rouge">false</code>Â otherwise, and so without needing to see any tokens of input.</p>

<h3 id="conflict-witnesses">Conflict Witnesses</h3>

<p>In case your parser is not LL(1), the methodÂ <code class="language-plaintext highlighter-rouge">conflicts</code>Â of the parser will return the set of allÂ <code class="language-plaintext highlighter-rouge">LL1Conflict</code>s. The various conflicts are:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NullableConflict</code>, which indicates that two branches of a disjunction are nullable.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FirstConflict</code>, which indicates that theÂ <code class="language-plaintext highlighter-rouge">first</code>Â set of two branches of a disjunction are not disjoint.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FollowConflict</code>, which indicates that theÂ <code class="language-plaintext highlighter-rouge">first</code>Â set of a nullable parser is not disjoint from theÂ <code class="language-plaintext highlighter-rouge">first</code>Â set of a parser that directly follows it.</p>
  </li>
</ul>

<p>TheÂ <code class="language-plaintext highlighter-rouge">LL1Conflict</code>s objects contain fields which can help you pinpoint the exact location of conflicts in your parser and hopefully help you fix those.
The helper methodÂ <code class="language-plaintext highlighter-rouge">debug</code>Â prints a summary of the LL(1) conflicts of a parser. We added code in the handout skeleton so that, by default, a report is outputted in case of conflicts when you initialise your parser.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Scallion is not the only parser combinator library to exist, far from it! Many of those libraries do not have this restriction. Those libraries generally need to backtrack to try the different alternatives when a branch fails.Â <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>SeeÂ <a href="https://stackoverflow.com/questions/357956/explanation-of-tying-the-knot">a good explanation of what tying the knot means in the context of lazy languages.</a>Â <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>
