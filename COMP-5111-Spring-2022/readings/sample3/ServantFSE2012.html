<html><head><title>Servant@FSE2012</title><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_list_3-8>li{counter-increment:lst-ctn-kix_list_3-8}.lst-kix_list_2-6>li{counter-increment:lst-ctn-kix_list_2-6}ol.lst-kix_list_2-0.start{counter-reset:lst-ctn-kix_list_2-0 0}ol.lst-kix_list_6-2.start{counter-reset:lst-ctn-kix_list_6-2 0}ol.lst-kix_list_5-8.start{counter-reset:lst-ctn-kix_list_5-8 0}ol.lst-kix_list_5-3.start{counter-reset:lst-ctn-kix_list_5-3 0}.lst-kix_list_6-6>li{counter-increment:lst-ctn-kix_list_6-6}.lst-kix_list_6-3>li:before{content:"" counter(lst-ctn-kix_list_6-3,decimal) ". "}.lst-kix_list_6-7>li:before{content:"" counter(lst-ctn-kix_list_6-7,lower-latin) ". "}ol.lst-kix_list_1-5.start{counter-reset:lst-ctn-kix_list_1-5 0}.lst-kix_list_6-2>li:before{content:"" counter(lst-ctn-kix_list_6-2,lower-roman) ". "}.lst-kix_list_5-1>li{counter-increment:lst-ctn-kix_list_5-1}.lst-kix_list_6-3>li{counter-increment:lst-ctn-kix_list_6-3}.lst-kix_list_3-3>li{counter-increment:lst-ctn-kix_list_3-3}ol.lst-kix_list_4-2.start{counter-reset:lst-ctn-kix_list_4-2 0}ol.lst-kix_list_2-3.start{counter-reset:lst-ctn-kix_list_2-3 0}.lst-kix_list_1-5>li{counter-increment:lst-ctn-kix_list_1-5}ol.lst-kix_list_6-4.start{counter-reset:lst-ctn-kix_list_6-4 0}.lst-kix_list_4-3>li:before{content:"" counter(lst-ctn-kix_list_4-3,decimal) ". "}ol.lst-kix_list_3-6.start{counter-reset:lst-ctn-kix_list_3-6 0}ol.lst-kix_list_3-0.start{counter-reset:lst-ctn-kix_list_3-0 0}ol.lst-kix_list_5-0.start{counter-reset:lst-ctn-kix_list_5-0 0}.lst-kix_list_1-0>li{counter-increment:lst-ctn-kix_list_1-0}.lst-kix_list_4-4>li{counter-increment:lst-ctn-kix_list_4-4}ol.lst-kix_list_2-1.start{counter-reset:lst-ctn-kix_list_2-1 0}.lst-kix_list_3-6>li:before{content:"" counter(lst-ctn-kix_list_3-6,decimal) ". "}.lst-kix_list_4-7>li{counter-increment:lst-ctn-kix_list_4-7}.lst-kix_list_4-5>li{counter-increment:lst-ctn-kix_list_4-5}.lst-kix_list_5-2>li:before{content:"" counter(lst-ctn-kix_list_5-2,lower-roman) ". "}ol.lst-kix_list_2-6.start{counter-reset:lst-ctn-kix_list_2-6 0}.lst-kix_list_6-8>li:before{content:"" counter(lst-ctn-kix_list_6-8,lower-roman) ". "}.lst-kix_list_3-2>li{counter-increment:lst-ctn-kix_list_3-2}ol.lst-kix_list_2-5.start{counter-reset:lst-ctn-kix_list_2-5 0}ol.lst-kix_list_1-7{list-style-type:none}ol.lst-kix_list_1-8{list-style-type:none}.lst-kix_list_1-6>li:before{content:"" counter(lst-ctn-kix_list_1-6,decimal) ". "}.lst-kix_list_5-4>li{counter-increment:lst-ctn-kix_list_5-4}.lst-kix_list_4-2>li{counter-increment:lst-ctn-kix_list_4-2}.lst-kix_list_6-8>li{counter-increment:lst-ctn-kix_list_6-8}.lst-kix_list_4-1>li{counter-increment:lst-ctn-kix_list_4-1}ol.lst-kix_list_1-8.start{counter-reset:lst-ctn-kix_list_1-8 0}ol.lst-kix_list_4-3.start{counter-reset:lst-ctn-kix_list_4-3 0}ol.lst-kix_list_1-4.start{counter-reset:lst-ctn-kix_list_1-4 0}ol.lst-kix_list_1-2{list-style-type:none}ol.lst-kix_list_4-5.start{counter-reset:lst-ctn-kix_list_4-5 0}ol.lst-kix_list_1-1{list-style-type:none}.lst-kix_list_2-1>li:before{content:"" counter(lst-ctn-kix_list_2-1,lower-latin) ". "}ol.lst-kix_list_1-0{list-style-type:none}.lst-kix_list_4-8>li:before{content:"" counter(lst-ctn-kix_list_4-8,lower-roman) ". "}ol.lst-kix_list_1-6{list-style-type:none}.lst-kix_list_3-0>li{counter-increment:lst-ctn-kix_list_3-0}ol.lst-kix_list_1-5{list-style-type:none}.lst-kix_list_5-5>li:before{content:"" counter(lst-ctn-kix_list_5-5,lower-roman) ". "}ol.lst-kix_list_1-4{list-style-type:none}ol.lst-kix_list_1-3{list-style-type:none}.lst-kix_list_1-1>li{counter-increment:lst-ctn-kix_list_1-1}.lst-kix_list_6-0>li{counter-increment:lst-ctn-kix_list_6-0}.lst-kix_list_2-0>li:before{content:"" counter(lst-ctn-kix_list_2-0,decimal) ". "}ol.lst-kix_list_1-2.start{counter-reset:lst-ctn-kix_list_1-2 0}.lst-kix_list_5-7>li{counter-increment:lst-ctn-kix_list_5-7}.lst-kix_list_4-6>li{counter-increment:lst-ctn-kix_list_4-6}.lst-kix_list_2-4>li:before{content:"" counter(lst-ctn-kix_list_2-4,lower-latin) ". "}ol.lst-kix_list_4-5{list-style-type:none}ol.lst-kix_list_4-4{list-style-type:none}.lst-kix_list_4-2>li:before{content:"" counter(lst-ctn-kix_list_4-2,lower-roman) ". "}ol.lst-kix_list_4-7{list-style-type:none}ol.lst-kix_list_4-6{list-style-type:none}ol.lst-kix_list_4-8{list-style-type:none}ol.lst-kix_list_2-4.start{counter-reset:lst-ctn-kix_list_2-4 0}ol.lst-kix_list_1-1.start{counter-reset:lst-ctn-kix_list_1-1 0}ol.lst-kix_list_5-8{list-style-type:none}ol.lst-kix_list_5-7{list-style-type:none}.lst-kix_list_2-1>li{counter-increment:lst-ctn-kix_list_2-1}.lst-kix_list_4-1>li:before{content:"" counter(lst-ctn-kix_list_4-1,lower-latin) ". "}ol.lst-kix_list_5-4{list-style-type:none}ol.lst-kix_list_5-3{list-style-type:none}ol.lst-kix_list_5-6{list-style-type:none}.lst-kix_list_5-2>li{counter-increment:lst-ctn-kix_list_5-2}ol.lst-kix_list_5-5{list-style-type:none}ol.lst-kix_list_1-0.start{counter-reset:lst-ctn-kix_list_1-0 0}ol.lst-kix_list_5-0{list-style-type:none}ol.lst-kix_list_5-1{list-style-type:none}.lst-kix_list_1-0>li:before{content:"" counter(lst-ctn-kix_list_1-0,decimal) ". "}ol.lst-kix_list_5-2{list-style-type:none}.lst-kix_list_2-4>li{counter-increment:lst-ctn-kix_list_2-4}.lst-kix_list_5-8>li:before{content:"" counter(lst-ctn-kix_list_5-8,lower-roman) ". "}ol.lst-kix_list_1-6.start{counter-reset:lst-ctn-kix_list_1-6 0}ol.lst-kix_list_4-0{list-style-type:none}ol.lst-kix_list_4-1{list-style-type:none}ol.lst-kix_list_4-2{list-style-type:none}ol.lst-kix_list_4-3{list-style-type:none}.lst-kix_list_3-4>li:before{content:"" counter(lst-ctn-kix_list_3-4,lower-latin) ". "}.lst-kix_list_1-3>li:before{content:"" counter(lst-ctn-kix_list_1-3,decimal) ". "}.lst-kix_list_5-8>li{counter-increment:lst-ctn-kix_list_5-8}ol.lst-kix_list_2-7.start{counter-reset:lst-ctn-kix_list_2-7 0}ol.lst-kix_list_6-5.start{counter-reset:lst-ctn-kix_list_6-5 0}.lst-kix_list_6-0>li:before{content:"" counter(lst-ctn-kix_list_6-0,decimal) ". "}.lst-kix_list_1-2>li{counter-increment:lst-ctn-kix_list_1-2}.lst-kix_list_4-0>li{counter-increment:lst-ctn-kix_list_4-0}.lst-kix_list_4-0>li:before{content:"" counter(lst-ctn-kix_list_4-0,decimal) ". "}.lst-kix_list_4-8>li{counter-increment:lst-ctn-kix_list_4-8}.lst-kix_list_5-6>li{counter-increment:lst-ctn-kix_list_5-6}.lst-kix_list_3-1>li:before{content:"" counter(lst-ctn-kix_list_3-1,lower-latin) ". "}.lst-kix_list_1-7>li:before{content:"" counter(lst-ctn-kix_list_1-7,lower-latin) ". "}.lst-kix_list_5-5>li{counter-increment:lst-ctn-kix_list_5-5}.lst-kix_list_3-1>li{counter-increment:lst-ctn-kix_list_3-1}.lst-kix_list_2-2>li{counter-increment:lst-ctn-kix_list_2-2}.lst-kix_list_5-1>li:before{content:"" counter(lst-ctn-kix_list_5-1,lower-latin) ". "}.lst-kix_list_1-1>li:before{content:"" counter(lst-ctn-kix_list_1-1,lower-latin) ". "}.lst-kix_list_3-2>li:before{content:"" counter(lst-ctn-kix_list_3-2,lower-roman) ". "}ol.lst-kix_list_6-3.start{counter-reset:lst-ctn-kix_list_6-3 0}ol.lst-kix_list_4-0.start{counter-reset:lst-ctn-kix_list_4-0 0}ol.lst-kix_list_4-8.start{counter-reset:lst-ctn-kix_list_4-8 0}.lst-kix_list_1-2>li:before{content:"" counter(lst-ctn-kix_list_1-2,lower-roman) ". "}.lst-kix_list_2-8>li{counter-increment:lst-ctn-kix_list_2-8}.lst-kix_list_1-5>li:before{content:"" counter(lst-ctn-kix_list_1-5,lower-roman) ". "}.lst-kix_list_2-3>li{counter-increment:lst-ctn-kix_list_2-3}.lst-kix_list_5-3>li{counter-increment:lst-ctn-kix_list_5-3}ol.lst-kix_list_6-0.start{counter-reset:lst-ctn-kix_list_6-0 0}ol.lst-kix_list_1-7.start{counter-reset:lst-ctn-kix_list_1-7 0}.lst-kix_list_2-3>li:before{content:"" counter(lst-ctn-kix_list_2-3,decimal) ". "}.lst-kix_list_1-4>li:before{content:"" counter(lst-ctn-kix_list_1-4,lower-latin) ". "}.lst-kix_list_5-7>li:before{content:"" counter(lst-ctn-kix_list_5-7,lower-latin) ". "}.lst-kix_list_2-0>li{counter-increment:lst-ctn-kix_list_2-0}ol.lst-kix_list_3-7.start{counter-reset:lst-ctn-kix_list_3-7 0}ol.lst-kix_list_6-7.start{counter-reset:lst-ctn-kix_list_6-7 0}.lst-kix_list_2-7>li:before{content:"" counter(lst-ctn-kix_list_2-7,lower-latin) ". "}.lst-kix_list_3-7>li{counter-increment:lst-ctn-kix_list_3-7}.lst-kix_list_1-8>li:before{content:"" counter(lst-ctn-kix_list_1-8,lower-roman) ". "}.lst-kix_list_1-6>li{counter-increment:lst-ctn-kix_list_1-6}.lst-kix_list_2-5>li{counter-increment:lst-ctn-kix_list_2-5}.lst-kix_list_3-3>li:before{content:"" counter(lst-ctn-kix_list_3-3,decimal) ". "}ol.lst-kix_list_6-1.start{counter-reset:lst-ctn-kix_list_6-1 0}ol.lst-kix_list_3-2.start{counter-reset:lst-ctn-kix_list_3-2 0}ol.lst-kix_list_1-3.start{counter-reset:lst-ctn-kix_list_1-3 0}.lst-kix_list_1-3>li{counter-increment:lst-ctn-kix_list_1-3}.lst-kix_list_6-4>li:before{content:"" counter(lst-ctn-kix_list_6-4,lower-latin) ". "}.lst-kix_list_2-7>li{counter-increment:lst-ctn-kix_list_2-7}.lst-kix_list_6-1>li:before{content:"" counter(lst-ctn-kix_list_6-1,lower-latin) ". "}.lst-kix_list_6-1>li{counter-increment:lst-ctn-kix_list_6-1}ol.lst-kix_list_6-8.start{counter-reset:lst-ctn-kix_list_6-8 0}.lst-kix_list_6-4>li{counter-increment:lst-ctn-kix_list_6-4}.lst-kix_list_4-7>li:before{content:"" counter(lst-ctn-kix_list_4-7,lower-latin) ". "}ol.lst-kix_list_5-7.start{counter-reset:lst-ctn-kix_list_5-7 0}.lst-kix_list_5-0>li{counter-increment:lst-ctn-kix_list_5-0}.lst-kix_list_6-5>li:before{content:"" counter(lst-ctn-kix_list_6-5,lower-roman) ". "}.lst-kix_list_2-6>li:before{content:"" counter(lst-ctn-kix_list_2-6,decimal) ". "}.lst-kix_list_3-6>li{counter-increment:lst-ctn-kix_list_3-6}ol.lst-kix_list_3-3.start{counter-reset:lst-ctn-kix_list_3-3 0}.lst-kix_list_2-2>li:before{content:"" counter(lst-ctn-kix_list_2-2,lower-roman) ". "}.lst-kix_list_1-7>li{counter-increment:lst-ctn-kix_list_1-7}ol.lst-kix_list_2-8.start{counter-reset:lst-ctn-kix_list_2-8 0}.lst-kix_list_2-8>li:before{content:"" counter(lst-ctn-kix_list_2-8,lower-roman) ". "}ol.lst-kix_list_2-0{list-style-type:none}ol.lst-kix_list_2-1{list-style-type:none}ol.lst-kix_list_2-2{list-style-type:none}.lst-kix_list_3-7>li:before{content:"" counter(lst-ctn-kix_list_3-7,lower-latin) ". "}ol.lst-kix_list_2-3{list-style-type:none}.lst-kix_list_3-4>li{counter-increment:lst-ctn-kix_list_3-4}ol.lst-kix_list_2-4{list-style-type:none}ol.lst-kix_list_2-5{list-style-type:none}ol.lst-kix_list_3-1{list-style-type:none}.lst-kix_list_6-6>li:before{content:"" counter(lst-ctn-kix_list_6-6,decimal) ". "}ol.lst-kix_list_3-2{list-style-type:none}ol.lst-kix_list_3-3{list-style-type:none}ol.lst-kix_list_3-4{list-style-type:none}ol.lst-kix_list_3-0{list-style-type:none}.lst-kix_list_1-8>li{counter-increment:lst-ctn-kix_list_1-8}ol.lst-kix_list_3-6{list-style-type:none}ol.lst-kix_list_3-5{list-style-type:none}ol.lst-kix_list_3-8{list-style-type:none}ol.lst-kix_list_3-7{list-style-type:none}ol.lst-kix_list_2-7{list-style-type:none}ol.lst-kix_list_2-6{list-style-type:none}.lst-kix_list_3-5>li:before{content:"" counter(lst-ctn-kix_list_3-5,lower-roman) ". "}ol.lst-kix_list_2-8{list-style-type:none}.lst-kix_list_3-5>li{counter-increment:lst-ctn-kix_list_3-5}ol.lst-kix_list_5-5.start{counter-reset:lst-ctn-kix_list_5-5 0}.lst-kix_list_4-6>li:before{content:"" counter(lst-ctn-kix_list_4-6,decimal) ". "}ol.lst-kix_list_6-4{list-style-type:none}ol.lst-kix_list_6-5{list-style-type:none}.lst-kix_list_5-3>li:before{content:"" counter(lst-ctn-kix_list_5-3,decimal) ". "}ol.lst-kix_list_6-2{list-style-type:none}ol.lst-kix_list_6-3{list-style-type:none}.lst-kix_list_4-5>li:before{content:"" counter(lst-ctn-kix_list_4-5,lower-roman) ". "}ol.lst-kix_list_6-8{list-style-type:none}ol.lst-kix_list_6-6{list-style-type:none}ol.lst-kix_list_6-7{list-style-type:none}.lst-kix_list_3-0>li:before{content:"" counter(lst-ctn-kix_list_3-0,decimal) ". "}.lst-kix_list_2-5>li:before{content:"" counter(lst-ctn-kix_list_2-5,lower-roman) ". "}ol.lst-kix_list_6-1{list-style-type:none}ol.lst-kix_list_6-0{list-style-type:none}.lst-kix_list_5-4>li:before{content:"" counter(lst-ctn-kix_list_5-4,lower-latin) ". "}ol.lst-kix_list_2-2.start{counter-reset:lst-ctn-kix_list_2-2 0}.lst-kix_list_4-4>li:before{content:"" counter(lst-ctn-kix_list_4-4,lower-latin) ". "}ol.lst-kix_list_4-7.start{counter-reset:lst-ctn-kix_list_4-7 0}ol.lst-kix_list_6-6.start{counter-reset:lst-ctn-kix_list_6-6 0}ol.lst-kix_list_4-4.start{counter-reset:lst-ctn-kix_list_4-4 0}.lst-kix_list_4-3>li{counter-increment:lst-ctn-kix_list_4-3}.lst-kix_list_5-0>li:before{content:"" counter(lst-ctn-kix_list_5-0,decimal) ". "}.lst-kix_list_6-5>li{counter-increment:lst-ctn-kix_list_6-5}ol.lst-kix_list_4-1.start{counter-reset:lst-ctn-kix_list_4-1 0}ol.lst-kix_list_3-5.start{counter-reset:lst-ctn-kix_list_3-5 0}ol.lst-kix_list_5-6.start{counter-reset:lst-ctn-kix_list_5-6 0}.lst-kix_list_3-8>li:before{content:"" counter(lst-ctn-kix_list_3-8,lower-roman) ". "}ol.lst-kix_list_3-4.start{counter-reset:lst-ctn-kix_list_3-4 0}.lst-kix_list_6-2>li{counter-increment:lst-ctn-kix_list_6-2}ol.lst-kix_list_4-6.start{counter-reset:lst-ctn-kix_list_4-6 0}ol.lst-kix_list_5-4.start{counter-reset:lst-ctn-kix_list_5-4 0}.lst-kix_list_1-4>li{counter-increment:lst-ctn-kix_list_1-4}.lst-kix_list_5-6>li:before{content:"" counter(lst-ctn-kix_list_5-6,decimal) ". "}ol.lst-kix_list_3-8.start{counter-reset:lst-ctn-kix_list_3-8 0}ol.lst-kix_list_5-1.start{counter-reset:lst-ctn-kix_list_5-1 0}ol.lst-kix_list_3-1.start{counter-reset:lst-ctn-kix_list_3-1 0}ol.lst-kix_list_5-2.start{counter-reset:lst-ctn-kix_list_5-2 0}.lst-kix_list_6-7>li{counter-increment:lst-ctn-kix_list_6-7}ol{margin:0;padding:0}.c20{padding-left:0pt;line-height:1.1500000000000001;padding-top:0pt;margin-left:54pt;padding-bottom:0pt}.c15{padding-left:0pt;line-height:1.1500000000000001;padding-top:0pt;margin-left:36pt;padding-bottom:0pt}.c26{line-height:1.1500000000000001;padding-top:0pt;margin-left:54pt;padding-bottom:0pt}.c23{color:#0000ff;font-size:11pt;font-family:"Arial"}.c4{color:#000000;font-size:11pt;font-family:"Arial"}.c22{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c9{color:#cc0000;font-size:11pt;font-family:"Arial"}.c14{color:#00ffff;font-size:11pt;font-family:"Arial"}.c21{color:#4a86e8;font-size:11pt;font-family:"Arial"}.c0{color:#ff0000;font-size:11pt;font-family:"Arial"}.c5{margin:0;padding:0}.c1{direction:ltr}.c6{font-size:12pt}.c13{color:#980000}.c12{color:#ff0000}.c10{font-style:italic}.c3{text-align:justify}.c24{font-size:14pt}.c25{color:#674ea7}.c17{color:#cc0000}.c19{color:#00ffff}.c8{text-indent:12pt}.c18{color:#85200c}.c16{text-align:center}.c11{text-decoration:underline}.c2{height:11pt}.c7{font-weight:bold}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:24pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}</style></head><body class="c22"><p class="c1 c16"><span class="c6">Reading report on </span></p><p class="c1 c16"><span class="c7 c24">History Slicing: Assisting Code-Evolution Tasks</span></p><p class="c1 c16"><span class="c6">(@FSE2012) prepared by Rongxin Wu</span></p><p class="c1"><span class="c6 c11 c7">Citation</span></p><p class="c1"><span>F. Servant, and J. A. Jones. &quot;History slicing: assisting code-evolution tasks.&quot; </span><span class="c10">Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering</span><span>, Research Triangle Park, NC, November 2012. </span></p><p class="c1"><span class="c6 c11 c7">Abstract</span></p><p class="c1"><span>Many software-engineering tasks require developers to understand the history and evolution of source code. However, today&#39;s software-development techniques and tools are not well suited for the easy and efficient procurement of such information. In this paper, we present an approach called history slicing that can automatically identify a minimal number of code modifications, across any number of revisions, for any arbitrary segment of source code at fine granularity. We also present our implementation of history slicing, CHRONOS, that includes a novel visualization of the entire evolution for the code of interest. We provide two experiments: one experiment automatically computes 16,000 history slices to determine the benefit brought by various levels of automation, and another experiment that assesses the practical implications of history slicing for actual developers using the technique for actual software maintenance tasks that involve code evolution. The experiments show that history slicing offered drastic improvements over the conventional techniques in three ways: (1) the amount of information needed to be examined and traced by developers was reduced by up to three orders of magnitude; (2) the correctness of developers attempting to solve software maintenance tasks was more than doubled; and (3) the time to completion of these software-maintenance tasks was almost halved.</span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c6 c11 c7">Key Targeted Problem</span></p><p class="c1"><span>The key targeted problem is to help developers understand the evolution for the code of interest.</span></p><p class="c1"><span>&nbsp;</span></p><p class="c1"><span class="c6 c11 c7">Inputs and Outputs</span></p><p class="c1"><span>Inputs: The code of interest, and the entire software repository.</span></p><p class="c1"><span>Outputs: The minimum complete evolution of the code set</span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c6 c11 c7">Research and Idea Pattern</span></p><p class="c1"><span>This paper targets on a very interesting problem &ndash; the exploration of the entire history of a set of lines of code. The problem is practical in reality but less studied by the previous researches. </span></p><p class="c1"><span>Previous researches [18, 22] found that developers often asked questions about why a snippet of source code had been implemented in a specific way, and to resolve such questions about the rationale of source code was highly time-consuming. Therefore, this paper propose a concept as well as a technique named history slicing, which automatically tracks the lineage of each line of code and enables querying and exploration of code evolution. &nbsp;</span></p><p class="c1 c2"><span></span></p><p class="c1 c3"><span class="c6 c11 c7">Major Contributions</span></p><ol class="c5 lst-kix_list_1-0 start" start="1"><li class="c15 c1"><span class="c4">Propose the concept of </span><span class="c4 c10">history slicing</span><span class="c4">, which can assist developers understand the code evolution. </span></li><li class="c15 c1"><span class="c4">Develop a tool, CHRONOS, which is an implementation of history slicing.</span></li><li class="c15 c1"><span class="c4">Conduct the experiment on the 16000 history-slicing tasks and evaluate the information overload that can be alleviated by their techniques compared with the existing tools.</span></li><li class="c15 c1"><span class="c4">Conduct a user study of actual developers and evaluate the real-world impact of their technique.</span></li></ol><p class="c1 c2"><span class="c4"></span></p><p class="c1"><span class="c6 c11 c7">Paper Summary<br></span></p><p class="c1"><span>This paper proposes a technique history slicing, which aims to help developers understand the code evolution. </span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c7">To motivate their work</span><span>, the paper lists three common scenarios that history slicing can be applied in. </span></p><ol class="c5 lst-kix_list_2-0 start" start="1"><li class="c15 c1"><span class="c4">Developers want to find an earlier implementation of specific piece of code.</span></li><li class="c15 c1"><span class="c4">A project manager may need to know all of the developers who ever modified a specific segment of source code. </span></li><li class="c1 c15"><span class="c4">Developers may want to explore the parallel history of multiple segments of source code in order to find out whether and when they were modified together. &nbsp;</span></li></ol><p class="c1"><span>The above scenarios are difficult to be answered by current SCM tools and require much manual effort. </span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c7">Slicing of History</span></p><p class="c1"><span>To resolve such questions, they propose the history slicing to obtain the whole history of a set of lines of code. Figure 1 shows an example of real world example. In the example, although there are at least 162 revisions for the source file AjBuildmanager.java, only revisions 1.1, 1.14, 1.60, 1.134, 1.156 and 1.162 contain changes to the lines of interest. </span></p><p class="c1 c2"><span></span></p><p class="c1 c16"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 626.72px; height: 224.36px;"><img alt="" src="images/image00.png" style="width: 626.72px; height: 224.36px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c7">Subtasks required for history slicing:</span></p><ol class="c5 lst-kix_list_3-0 start" start="1"><li class="c15 c1"><span class="c4">Retrieve the previous revision r of a file</span></li><li class="c15 c1"><span class="c4">Find inside revision r which lines correspond to the lines of interest</span></li><li class="c15 c1"><span class="c4">Check the contents of those lines and identify whether they were modified</span></li><li class="c15 c1"><span class="c4">If they were modified, save them. Return to Step 1 until all history is explored</span></li></ol><p class="c1 c2"><span></span></p><p class="c1"><span class="c18">[Valerio: I am interesting to know if exist sophisticated approach for judging if a line is modified, or replaced with an unrelated line (different semantic). The author of the paper they do not address this interesting problem they just said &ldquo;our framework allows the choice of line mapping to be customized according to the tasks at hand&rdquo;] </span><span class="c12">[Wu: Yes. To do the line mapping, they only used Levenshtein distance [23] to compute an optimal mapping among lines in such change blocks. Actually, this is not a semantic way. I think doing semantic analysis for line mapping could be more helpful to understand the code-evolution but requires more cost. ] </span></p><p class="c1 c2"><span class="c4"></span></p><p class="c1"><span>To finish the subtasks of history slicing, there are several possible approaches:</span></p><ol class="c5 lst-kix_list_4-0 start" start="1"><li class="c15 c1"><span class="c4 c7">Manual, naive slicing of history</span><span class="c4">: To finish subtask 1, manually check all the versions of a certain source file; to finish subtask 2, in worse case, manually inspect the full content of the source files; in subtask 3, the comparison between two revisions might be even more difficult when the source file contains a large number of lines of code; to finish subtask 4, keep record all the log of snapshots of different revisions for all the file. &nbsp;</span></li><li class="c15 c1"><span class="c4 c7">Conventionally assisted slicing of history</span><span class="c4">: To finish subtask 1, utilize the annotate/blame feature on the revision of interest; to finish subtask 2, run </span><span class="c4 c10">diff </span><span class="c4">over r and r-1; to finish subtask 3, </span><span class="c4 c10">annotate</span><span class="c4">&nbsp;can help determine whether snapshots of two revisions are different; to finish subtask 4, it still requires manual effort.</span><span class="c19">&nbsp;</span></li><li class="c15 c1"><span class="c4 c7">Automation of history slicing: </span><span class="c4">it does not strictly follow the subtasks and is composed of the four steps as following:</span></li></ol><ol class="c5 lst-kix_list_5-0 start" start="1"><li class="c1 c20"><span class="c4">Build history graph: &nbsp;History graph is a graph that contains the history of each line of each source file. Take figure 3 for example, in the history graph, each node represents a line of code in a specific revision, and each node contains a label which describes the operation that produced each line in each revision.</span><span class="c14">&nbsp;</span><span class="c23">[Wensheng: In the evolution of source code, refactoring to the source code is very common, for example, renaming a class, extracting a class, extracting a method, pulling up/down a method, and so on. In these situations, the relationship between the old code and new code can&rsquo;t be captured by the line mapping. For example, renaming class A to class B will make the history broken. How did they deal with these situations?]</span><span class="c9">[Valerio:Yes this case is indeed very common, I think they consider this possibility</span><span class="c17">&nbsp;as &nbsp;configuration parameters</span><span class="c9">]</span><span class="c25">[Qidan: I think they still have to rely on annotation/blame record and other information of version control system to build the graph, so this actually seems more like an improvement of approach 2] </span><span class="c12">[Wu: Actually, when doing line mapping, their approach is based on diff and combined Kuhn-Munkres combinatorial optimization algorithm with Levenshtein distance algorithm. ]</span></li></ol><p class="c1 c16 c26"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 337.00px; height: 186.00px;"><img alt="" src="images/image01.png" style="width: 337.00px; height: 186.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><ol class="c5 lst-kix_list_5-0" start="2"><li class="c20 c1"><span class="c4">Select slicing criterion: select a slicing criterion, which contains a set of lines of interest from a specific revision of a source file.</span></li><li class="c20 c1"><span class="c4">Traverse history graph: start from the nodes that represent the selecting criterion and traverse all the nodes included in the history path of all the lines of code in the slicing criterion. A history path for a line of code includes all the changes to it, from the moment that it was initially conceived, until it is deleted or is part of the newest revision of the file.</span></li><li class="c20 c1"><span class="c4">Represent history slicing: visualize the history slice.</span></li></ol><p class="c1 c2"><span class="c4"></span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c6 c11 c7">Evaluation</span></p><p class="c1 c2"><span class="c4"></span></p><p class="c1"><span>To evaluate their approach, they propose three research questions:</span></p><p class="c1"><span class="c7">RQ1: How much does the automation of history slicing reduce the problem space in terms of the total number of lines of code needing to be examined?</span></p><p class="c1"><span class="c7">RQ2: How much does the size of the slicing criterion affect the problem space reduction (in both the time and space dimensions)?</span></p><p class="c1"><span class="c7">RQ3: What is its practical benefit to developers performing code evolution tasks?</span></p><p class="c1 c2"><span class="c7"></span></p><p class="c1"><span>To answer RQ1 and RQ2, the paper designs the experiment 1. They randomly generate 1000 slicing criteria at different size levels (the size of criteria as 10, 20, and 50), and compare four different technique treatments (naive approach, conventionally assisted approach, history slicing with context, and history slicing without context). Naive approach and conventionally assisted approach are corresponding to the above description of &ldquo;</span><span class="c7">Manual, naive slicing of history</span><span>&rdquo; and &ldquo;</span><span class="c7">Conventionally assisted slicing of history</span><span>&rdquo;. The history slicing with context approach and history slicing without context approach are corresponding to the description of &ldquo;</span><span class="c7">Automation of history slicing</span><span>&rdquo;, and the only difference is that the unchanged-yet-correlated code is taken into account or not. To evaluate the benefit, they use the following metrics: </span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c7">Number of Revisions:</span><span>&nbsp;The number of revisions in the history of the slicing criterion that need to be examined.</span></p><p class="c1"><span class="c7">Average Number of Lines for a Revision:</span><span>&nbsp;The average number of lines of code that a developer would need to inspect in each revision. This is computed as the average number of lines for any given revision inside the history slice, aggregated across all relevant revisions, according to the different techniques.</span></p><p class="c1"><span class="c7">Total Number of Lines for a Task:</span><span>&nbsp;The total number of lines of code that a developer would need to examine across all relevant revisions. This is computed as the sum of all examined lines across all relevant revisions, according to the treatment technique. This serves as a proxy measure of the total amount of work that a developer would need to expend to fully explore and process the history slice. </span></p><p class="c1 c2"><span></span></p><p class="c1 c16"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.62px; height: 241.08px;"><img alt="" src="images/image02.png" style="width: 301.62px; height: 241.08px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>&nbsp; </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.54px; height: 270.52px;"><img alt="" src="images/image03.png" style="width: 303.54px; height: 270.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span>From table 1 and figure 5, the History Slicing with Context and History Slicing without Context overwhelm the other two approaches, in terms of saving the developers&rsquo; effort. </span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>To evaluate RQ3, the paper designs the experiment 2. They compare two technique treatments (conventionally assisted approach and history slicing with context) in three code-evolution tasks. </span></p><p class="c1"><span class="c7">Task 1: Authorship</span><span>. That is to identify the complete set of developers who had ever contributed changes to a segment of code.</span></p><p class="c1"><span class="c7">Task 2: Original Revision</span><span>. That is to identify the original revision in which a segment of code was originally created.</span></p><p class="c1"><span class="c7">Task 3: Co-evolution</span><span>. That is to identify the revisions in which two segments of code in two different files were changed within a day of each other. This task reflects the demand of determining &ldquo;evolutionary coupling&rdquo; for identifying related code or code-clone risk.</span></p><p class="c1 c2"><span></span></p><p class="c1"><span>To evaluate RQ3, the paper adopts the </span><span class="c7">Time to Task Completion</span><span>&nbsp;and </span><span class="c7">Task Success </span><span>as the evaluation metrics. Besides, since experiment 2 is a comparative study and related to human effort, they control two variables &ndash; user subject skill and task order and avoid the outside influence. 24 students are recruited, and separated into two groups with same number of subjects. &nbsp;[</span><span class="c13">Valerio: In my opinion their evaluation setup does not emulate a real world usage of the tool. The subjects are not developers of the program subjects used in the experiments, they are not familiar with the project source code and history, in this way of course an automatic aid is more effective than manual inspection. In fact, Task 1 and Task 2 would be much more easy to perform if the human subjects are developers of a specific software. Despite that separating the subjects in two groups one using the tool and the other not using the tool I think is the right way to evaluate the effectiveness of an end-user tool</span><span>&nbsp;] [</span><span class="c12">Wu: In my opinion, it is also potentially useful to perform Task 1 and Task 2 by using the history slicing. Especially when the software is large scale and has been evolved with a long period, it may be much more difficult to perform these two tasks. </span><span>][</span><span class="c13">Valerio: Yes, I am not saying that this approach is useless, I am just saying that In my opinion they should have evaluated their tool in another way]</span></p><p class="c1 c16"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 508.42px; height: 229.43px;"><img alt="" src="images/image04.png" style="width: 508.42px; height: 229.43px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span>Table 3 shows the evaluation result. The result provides strong evidence that the task of computing history slice is a non-trivial task for developers to compute on their own with current toolkits. </span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c6 c7 c11">Reflection</span></p><p class="c1 c8"><span>This paper focuses on how to help developers understand the code-evolution tasks. The paper borrows the concept of program slicing and applies it to understand the source code in different versions. Although the technique is simple, it is useful and effective in practice. </span></p><p class="c1 c8"><span>Especially, we can learn from two lessons from this paper: (1) How to motivate our work: The paper uses previous empirical studies and lists some possible scenarios to motivate their work. (2) How to design the experiment to evaluate the effectiveness of the techniques: the experiment 2 in the paper is very impressive, and we can learn the way of conducting a comparative study in this paper. [</span><span class="c13">Valerio: why do you think is very impressive ?] [</span><span class="c12">Wu: They introduced the human factor in the evaluation of experiment which is rare but important in software engineering researches. Although there are still some limitations in controlling the variables in the experiment, it still provides a good case for us to learn how to conduct the comparative studies. &nbsp;</span><span class="c13">]</span></p><p class="c1 c8"><a name="h.kx3gvnkwj7"></a><span>One thing that I feel not good is that they described their approach in a redundant way, as is described in Section 4 and Section 5. [</span><span class="c13">Valerio: regarding the acceptance criteria. </span></p><p class="c1 c8"><a name="h.bjl4lka5rkjk"></a><span class="c13">In a scale 1 to 5 I think that</span></p><p class="c1 c8 c2"><a name="h.awb3ckcj591a"></a></p><p class="c1 c8"><a name="h.4vw0qzyzgxsk"></a><span class="c13">Novelty: 4</span></p><p class="c1 c8"><a name="h.9w48eg1f9h83"></a><span class="c13">Challenge: 1</span></p><p class="c1 c8"><a name="h.gjdgxs"></a><span class="c13">Usefulness: 3]</span></p></body></html>