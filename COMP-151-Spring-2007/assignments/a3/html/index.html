<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>a1: COMP151 Programming Assignment 3, Spring 2007</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>COMP151 Programming Assignment 3, Spring 2007</h1>
<p>
<b>Author:</b> <a href="http://www.cs.ust.hk/~dekai/">Dekai Wu</a><p>
<b>Date:</b> Due 2007.04.27 at 23:00 by CASS<p>
<b>Download:</b> <a href="../../../assignments/a3.tar.gz">http://www.cs.ust.hk/~dekai/151/assignments/a3.tar.gz</a><p>
<b>Assignment page:</b> <a href="../../../assignments/a3/html/index.html">http://www.cs.ust.hk/~dekai/151/assignments/a3/html/</a><p>
<b>Course page:</b> <a href="../../../index.html">http://www.cs.ust.hk/~dekai/151/</a><p>
<h3>Your assignment</h3>
<p>
In this third piece of your programming project, you are assigned to maintain and extend the expression evaluator code built in <a href="../../../assignments/a2/html/index.html">Assignment 2</a>. Your job this time is to take the following steps.<p>
<h3>Step 1: Handle errors using exceptions</h3>
<p>
The first step is to fix your program so that whenever it encounters an error condition, it follows more solid software engineering practice by throwing an exception, instead of ungracefully printing an error message and exiting.<p>
To support this, the <code><a class="el" href="main_8cpp.html">main.cpp</a></code> driver program we give you has been modified so that the read-eval-print loop catches all <code>runtime_exception</code> objects you might throw. Our exception handler will print "ERROR: " followed by the specific message string obtained by calling the <code>what()</code> member function on the <code>runtime_exception</code> object you threw (so try to supply useful, meaningful error messages). Then, instead of clumsily exiting the program, it will go back to the beginning of the read-eval-print loop and await another input expression.<p>
<h3>Step 2: Support definition and use of symbols</h3>
<p>
The next step is to add the capability to define symbols, i.e., symbolic variables. (In the next step, you will add the capability to use the symbols that have been defined.)<p>
Here's how to proceed. In addition to all the operators from Assignments 1 and 2, you are to add a new <code>define</code> operator. This operator accepts exactly two operands, as for example in <code>(define x (* (+ 2 3) 6))</code>. The first operand must be a symbol, while the second operand can be of any type. The return value from a <code>define</code> expression is <em>always</em> nil, i.e., the empty list <code>()</code>, so the return value is irrelevant. Instead, the real point is that after evaluating the expression <code>(define x (* (+ 2 3) 6))</code> the symbol <code>x</code> will be <em>bound</em> to <code>30</code>.<p>
In C++, this is roughly analogous to a variable definition with an initial value, as in <code>int x((2 + 3) * 6)</code>.<p>
Note that symbols may <em>not</em> be redefined. So if <code>x</code> has already been defined as above, then evaluating <code>(define x 42)</code> should generate an error. (This is roughly analogous in C++ to saying that all variable definitions must be constant, as in <code>const int x((2 + 3) * 6)</code>. Later on, we'll explore the possibility of allowing existing variables to be <em>rebound</em> via an assignment operator.)<p>
To accomplish this, you are to implement a global <em>symbol table</em> using the <code>map</code> container template you learned about in <a href="../../../labs/lab12/index.html">lab</a>. You will use the <code>map</code> container to remember what values have been bound to what symbols. The <code>map</code> container gives you a dictionary data structure, so the interface is slightly more powerful than the sequence containers we discussed in lecture. You are to instantiate the <code>map</code> container using the template parameters <code>map&lt;string, Cell*&gt;</code>. The string is to be used hold a symbol name, while the Cell is to be used to hold a copy of the value that the symbol is bound to. (To learn how to use <code>map</code>, consult your textbook, the lab pages, and/or the reference pages mentioned in the lecture slides.)<p>
Next, you should extend your evaluator so that if <code><a class="el" href="eval_8hpp.html#6e55b5c1dddfa3a8b0885d50cdaec560">eval()</a></code> is called on a previously defined symbol, then it will return the value that the symbol has been bound to. So assuming <code>x</code> has been defined as in the foregoing example, then later on, evaluating the expression <code>(- 100 x)</code> should return the value <code>70</code>.<p>
Note that in this step, we are changing the specification of what it means to evaluate a symbol! Unlike in Assignments 1 and 2, evaluating a symbol <code>foo</code> no longer simply returns <code>foo</code>. Instead, you need to look up the symbol name <code>foo</code> in the symbol table, and return the value bound to that symbol name.<p>
Here's an extended example session with a correct implementation:<p>
<code>% main<br>
 &gt; (define a 3)<br>
 ()<br>
 &gt; a<br>
 3<br>
 &gt; (define asquared (* a a))<br>
 ()<br>
 &gt; asquared<br>
 9<br>
 &gt; (define b 4.0)<br>
 ()<br>
 &gt; b<br>
 4.0<br>
 &gt; (define csquared (+ asquared (* b b)))<br>
 ()<br>
 &gt; csquared<br>
 25.0<br>
 &gt; (+ csquared 1)<br>
 26.0<br>
 &gt; csquared<br>
 25.0<br>
 &gt; (define foo (quote hello))<br>
 ()<br>
 &gt; foo<br>
 hello<br>
 &gt; bar<br>
 ERROR: attempt to reference an undefined symbol "bar"<br>
 &gt; (define baz hello)<br>
 ERROR: attempt to reference an undefined symbol "hello"<br>
 &gt; </code><p>
Note that evaluating a symbol that has not already been defined should generate an error.<p>
Also note that it results in undefined behavior if you try to evaluate an expression containing both a <code>(define x ...)</code> and also some use of the value of <code>x</code>. For example, <code>(+ x (define x 4))</code> does not result in well-defined behavior. This is because <code><a class="el" href="eval_8hpp.html#6e55b5c1dddfa3a8b0885d50cdaec560">eval()</a></code> does not guarantee what order the operands are evaluated, so we cannot predict what value (if any) <code>x</code> will have at the time it is evaluated.<p>
<h3>Step 3: Support boolean expressions</h3>
<p>
Add boolean expressions using the less than <code>&lt;</code> and <code>not</code> operators, both of which return either 0 or 1 int values, representing false and true respectively.<p>
The <code>&lt;</code> operator accepts zero or more operands, each of which can be either int or double, returning 0 if any two consecutive operands are not monotonically increasing, and 1 otherwise.<p>
<code>&gt; (&lt; 3 4)<br>
 1<br>
 &gt; (&lt; 4.2 3)<br>
 0<br>
 &gt; (&lt; 3 3.0)<br>
 0<br>
 &gt; (&lt;)<br>
 1<br>
 &gt; (&lt; 3)<br>
 1<br>
 &gt; (&lt; 3 4 6 8 9)<br>
 1<br>
 &gt; (&lt; 3 6 4 8 9)<br>
 0<br>
 </code><p>
The <code>not</code> operator accepts exactly one operand, returning 1 if the operand is zero (either int or double), and 0 otherwise.<p>
<code>&gt; (not 0)<br>
 1<br>
 &gt; (not (- 3.2 3.2))<br>
 1<br>
 &gt; (not 1)<br>
 0<br>
 &gt; (not 4.2)<br>
 0<br>
 &gt; (not (&lt; 7 8))<br>
 0<br>
 </code><p>
Your boolean expressions will be especially useful in conjunction with your existing <code>if</code> operator which, recall, evaluates the first argument, and then evalutes and returns the second argument if the first argument evaluated to a non-zero value, otherwise evaluating and returning the third argument (remember that this <b>short-circuit</b> evaluation method is critically important):<p>
<code>&gt; (if (&lt; 4 3) 66 77)<br>
 77<br>
 </code><p>
Recall that the behavior of <code>if</code> is analogous to the <em>&lt;bool&gt;</em> <code>?</code> <em>&lt;then&gt;</em> <code>:</code> <em>&lt;else&gt;</em> operator in C++.<p>
<h3>Step 4: Expose <code>print</code> and <code>eval</code> in Scheme</h3>
<p>
Finally, you will expose your existing C++ implementation of <code>print</code> and <code>eval</code> so that they can be called from Scheme, just like you already did in Assignment 2 for the <code>cons</code>, <code>car</code>, <code>cdr</code>, and <code>nullp</code> operators.<p>
The <code>print</code> operator accepts one operand, which it evaluates, printing the resulting value onto the <code>cout</code> output stream. The return value from a <code>print</code> expression is <em>always</em> nil, i.e., the empty list <code>()</code>.<p>
<code>&gt; (print (+ 1 2))<br>
 <b>3</b><br>
 ()<br>
 &gt; (print (quote (+ 1 2)))<br>
 <b>(+ 1 2)</b><br>
 ()<br>
 </code><p>
The <code>eval</code> operator accepts one operand, and returns the result of evaluating the operand:<p>
<code>&gt; (cons (quote +) (quote (1 2)))<br>
 (+ 1 2) <br>
 &gt; (eval (cons (quote +) (quote (1 2))))<br>
 3 <br>
 &gt; (quote (cons (quote +) (quote (1 2))))<br>
 (cons (quote +) (quote (1 2))) <br>
 &gt; (eval (quote (cons (quote +) (quote (1 2)))))<br>
 (+ 1 2) <br>
 &gt; (eval (eval (quote (cons (quote +) (quote (1 2))))))<br>
 3<br>
 </code><p>
<h3>Optional bonus: Clean up your evaluator using function templates</h3>
<p>
Use function templates to eliminate the redundancy in your previous implementation of the evaluator. You should have noticed that your previous implementation of the addition, subtraction, multiplication, and division functions looked almost identical for both <code>IntCell</code> and <code>DoubleCell</code> operands. You probably did a lot of "reuse by copying". This seems wasteful, ugly, bug-prone, and hard to maintain. Really you should be able to use function templates so that you only have one copy of the code, that can be instantiated for all the different cases.<p>
Please note that you should <em>not</em> remove the polymorphism from your Assignment 2 implementation. The use of function templates is <em>in addition to</em> your existing virtual functions, and is just to make your existing functions more concise.<p>
After this step, <code><a class="el" href="parse_8cpp.html#0c86c1253ed6de8893e3843e4e606d65">parse()</a></code> and any other functions that made proper use of the interface encapsulated by <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code> or <code><a class="el" href="Cell_8hpp.html">Cell.hpp</a></code> should all still work.<p>
<h3>Putting it all together and testing your implementation</h3>
<p>
Except for the modified version of <code><a class="el" href="main_8cpp.html">main.cpp</a></code>, all other source files in <code>a3.tar.gz</code> are identical to those from <code>a2.tar.gz</code>.<p>
So you should start from your Assignment 2 implementation and extend it, replacing only the old <code><a class="el" href="main_8cpp.html">main.cpp</a></code> with the new one. Be careful! You still may not break any of the encapsulation rules from Assignment 2.<p>
The a3.tar.gz tarball contains many development test cases to help you with testing your implementation. They are broken into three categories: easy cases (<code>testinput.dev.easy.txt</code>), general cases (<code>testinput.dev.general.txt</code>, and exception cases (<code>testinput.dev.exception.txt</code>). All the correct outputs are also given to you for both the easy cases (<code>testinput.dev.easy.ref.txt</code>) and the general cases (<code>testinput.dev.general.ref.txt</code>).<p>
Your submitted implementation will be graded using a similar (but different) set of test cases.<p>
In addition, the tarball contains the binary executable of a reference solution (compiled for the Linux lab machines you are supposed to be using). You can run this program to see the possible behavior of a correct solution. (Note that your implementation might give different results for some error cases, because for all operators other than <code>if</code>, we have deliberately avoided specifying what order the operands are evaluated and checked. This could lead to different errors being discovered first, causing evaluation to be prematurely aborted when the exception is thrown.)<p>
Remember, the objective of this programming project is for you to train your skills, by practicing correct software engineering techniques enabling you to build, maintain, and extend a non-trivial piece of well-engineered code.<p>
<h3>Important reminders</h3>
<p>
You must follow the design approach outlined in this document. Do <em>not</em> just implement the required functionality using a different design.<p>
This time you <em>must</em> use templates. In this assignment, you are expected to make good use of the STL <code>map</code> - but neatly, without messing up the polymorphic approach you built in Assignment 2.<p>
Remember we are focusing on proper use of encapsulation. So you still should <em>not</em> edit the files <code><a class="el" href="parse_8hpp.html">parse.hpp</a></code>, <code><a class="el" href="parse_8cpp.html">parse.cpp</a></code>, <code><a class="el" href="cons_8hpp.html">cons.hpp</a></code>, <code><a class="el" href="eval_8hpp.html">eval.hpp</a></code>, or <code><a class="el" href="main_8cpp.html">main.cpp</a></code>. Again, the programming assignments are mini-exercises in how multiple programmers are supposed to interact and communicate in the real world; these files are <em>owned</em> and <em>maintained</em> by the other author(s).<p>
You will need to turn in your own improved and extended implementation of <code>eval.cpp</code>. Depending on your approach, you may or may not also wish to add more files.<p>
Depending on your approach, you may or may not need to change the <code>Makefile</code>. Whether you changed it or not, always make sure you include whatever <code>Makefile</code> is needed to build your program, when you submit assignment. Otherwise, the graders cannot build your program.<p>
You must write the final version of the program on your own. Sophisticated plagiarism detection systems are in operation, and they are pretty good at catching copying! If you worked in study groups, you must also acknowledge your collaborators in the write-up for each problem, whether or not they are classmates. Other cases will be dealt with as plagiarism. Re-read the policy on the course home page, and note the University's tougher policy this year regarding cheating.<p>
<b>Your programming style (how clearly and how well you speak C++) is what will be graded. Correct functioning of your program is necessary but not sufficient!</b> <hr size="1"><address style="align: right;"><small>Generated on Sat Apr 21 00:06:25 2007 for a1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
