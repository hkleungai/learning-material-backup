<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=x-user-defined">
   <meta name="Author" content="minh le">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <title>670PROJ_IO</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<center>
<h1>
Approximation Algorithms --&nbsp; COMP 670J</h1></center>

<center>
<h1>
Class Project FAQ</h1></center>

<p><br><font size=+1>This file contains tips and answers to frequently
asked question concerning&nbsp; the COMP670J project. It will be updated
frequently in response to your questions so I suggest that, at least for
the first week or so, you check it every few days for additions.</font><font size=+1></font>
<p><font size=+1>LAST UPDATE:&nbsp; <i>Mon Dec&nbsp; 3 11:15:14 HKT 2001</i></font>
<br><font size=+1></font>&nbsp;
<br><font size=+1></font>&nbsp;
<li>
<font size=+1><i>Linear Programming:</i>&nbsp; There are many LP solvers
available in books and on the web.&nbsp; One possible source is the book&nbsp;
<i>Numerical Recipes in C</i>, which contains a general purpose simplex
routine (the ``simplex method'' is one of the standard ways of solving
LP problems).&nbsp; The book is available in the library and an older version
is available on line <a href="http://www.ulib.org/webRoot/Books/Numerical_Recipes/bookc.html">here.</a>
(The simplex code is in section 10.8)</font></li>

<br><font size=+1></font>&nbsp;
<p>&nbsp;<font size=+1></font>
<p><font size=+1>Another place to look is&nbsp; <a href="http://www.zib.de/Optimization/Software/Soplex/">here</a>&nbsp;&nbsp;
which has links to an object-oriented simplex library.&nbsp; This looks
more complicated to use than the Numerical Recipes code,&nbsp; though.
Yet another place to look is&nbsp; the <a href="http://www-unix.mcs.anl.gov/otc/Guide/faq/linear-programming-faq.html">linear
programming FAQ.</a></font>
<br><font size=+1></font>&nbsp;
<br><font size=+1></font>&nbsp;
<li>
<font size=+1>In the <i>TSP project </i>you will need to implement MST,
Euler tour and Minimum cost weighted&nbsp; matching algorithms as subroutines.&nbsp;&nbsp;
MST can be found in&nbsp; most textbooks on algorithms,&nbsp; e.g.,&nbsp;
the Cormen, Leiserson, Rivest, ``Introduction to Algorithms'' book.&nbsp;
That same book has Euler Tour'' as an exercise (page 496) with hints.&nbsp;
The Minimum cost weighted&nbsp; matching algorithm is the hardest of the
three and,&nbsp; in my opinion,&nbsp; is where most of the work in this
project will be needed.&nbsp; The best description of the algorithm that
I know of is in the book ``Combinatorial Optimization'' by Steiglitz and&nbsp;
Papadimitriou,&nbsp; Chapter 11,&nbsp; section 11.3,&nbsp; if you have
trouble finding the&nbsp; book please come and see me to photocopy the
relevant section.</font></li>
<font size=+1></font>
<p><br><font size=+1>You can also&nbsp; check out <a href="ftp://dimacs.rutgers.edu/pub/netflow/matching/weighted">this
code. </a>It contains code for a weighted matching solver (it solves for
max weighted matching but you can easily use this for min matching by negating
the edge costs).&nbsp; I haven't tested it myself but it looks as if it
should be useful for you.&nbsp; One warning;&nbsp;&nbsp; you'll have to
compile a package.</font>
<br><font size=+1></font>&nbsp;
<li>
<font size=+1>In the&nbsp; <i>Shortest Superstring</i> project you will
need to implement a Minimum cost <i>bipartite</i> weighted&nbsp; matching
algorithm. The algorithm for this problem (much&nbsp; easier than&nbsp;
the one for the&nbsp; general case) can also be found in Steiglitz and&nbsp;
Papadimitriou,&nbsp; Chapter 11, this time in section 11.2.&nbsp; This
problem is sometimes also known as the <i>assignment problem</i> and the
algorithm for solving it,&nbsp; the <i>Hungarian algorithm</i>.&nbsp;&nbsp;&nbsp;
I've been told that the book&nbsp; <i>The Stanford GraphBase </i>by Donald
Knuth,&nbsp; available in our library,&nbsp; also contains good Hungarian
algorithm code. Of course,&nbsp; you can also use the code for solving
the general min-cost weighted matching problem to solve the bipartite case
as well (it's just longer and more compkicated code).</font></li>

<br><font size=+1></font>&nbsp;
<li>
<font size=+1>The <a href="http://www.cs.sunysb.edu/~algorith">Stony Brook
Algorithm Repository&nbsp; </a>is a good place to look for algorithm code.&nbsp;
In particular their <a href="http://www.cs.sunysb.edu/~algorith/files/linear-programming.shtml">linear
program section </a>(1.2.6) has pointers to various LP solvers.</font></li>

<br><font size=+1></font>&nbsp;
<p>&nbsp;
<br>&nbsp;<font size=+1></font>
<br><font size=+1></font>&nbsp;
<li>
<font size=+1>In the <i>SONET Ring</i> paper there is a typo in the proof
of&nbsp; Proposition 4.2 on page 6.&nbsp; The 9th line of the page starts
with M = D_{g,h} - C_g - C_h.&nbsp; This is a mistake. It should be M =
C_g + C_h -&nbsp; D_{g,h}.$</font></li>

<br><font size=+1></font>&nbsp;
<p>&nbsp;<font size=+1></font>
<p><font size=+1>For&nbsp; this project you should be aware that even though
the algorithm is&nbsp; not difficult the paper is not that easy to read;&nbsp;
it will occasionally skip steps that you have to fill in for yourselves.&nbsp;&nbsp;
If you are doing this project and are having difficulty with the paper
please come and see me and we can work through the bottlenecks.</font>
<br><font size=+1></font>&nbsp;
<br><font size=+1></font>&nbsp;
<br><font size=+1></font>&nbsp;
<li>
<font size=+1>&nbsp;Added&nbsp; <i>Mon Dec&nbsp; 3 11:15:14 HKT 2001</i></font></li>

<br><font size=+1>Q:&nbsp;What do you mean by&nbsp; <i>a short description
of how you will generate the data upon which you will test the performance
of your program?</i></font><i><font size=+1></font></i>
<p><font size=+1>A: You should send me two things.</font>
<br><font size=+1>(i)&nbsp; for each set of parameters describe how you
will generate the random data for the set of parameters.</font>
<br><font size=+1>Please address any issues that you considered when choosing
this data generation method, e.g., how</font>
<br><font size=+1>well the data will test the approximation algorithm.</font><font size=+1></font>
<p><font size=+1>As an example,&nbsp; in&nbsp; <b>Max-Sat</b> the parameters
are&nbsp; <i>m = number of variables</i> and <i>n = number of clauses.</i></font>
<br><font size=+1>In this case you need to describe how for any given&nbsp;
(m,n)&nbsp;you will generate a random instance.</font>
<br><font size=+1>An issue that you need to consider here is how to choose
the number of variables in a particular</font>
<br><font size=+1>clause. &nbsp;If,&nbsp; for example,&nbsp; you let every
clause have greater than 8 variables then, from the analaysis in the notes,
we see that every clause has probability >&nbsp; .99 of being satsified.&nbsp;
So,&nbsp; taking instances with&nbsp; clauses of length > 8 will not really
test the&nbsp; differences between the random algorithm and best-of-two
very well;&nbsp; you need to somehow guarantee&nbsp; many short clauses.&nbsp;
In particular,&nbsp; the strategy of letting a variable have 50% probability
of appearing in each clause is not a good generation method if the number
of variable is > 16 or so.&nbsp; <b>Max-Sat is </b>is just an example,&nbsp;
many of the projects have similar considerations.</font><font size=+1></font>
<p><font size=+1>(ii) After describing how you will generate a random data
set for a particular set of parameters you will need to also specify for
what values of the parameters you will generate the data sets and,&nbsp;
how many times for each set of parameters (I&nbsp;recommend at least 10).&nbsp;
As an example,&nbsp; in <b>Max-Sat </b>you might</font>
<br><font size=+1>decide to let&nbsp; m=3, 6, 9, 12 15, 25, 30&nbsp; n
= 5, 10, 15, 20, 25,30, 35, 40,&nbsp; 45, 50,&nbsp; 55, 60 and, for each,</font>
<br><font size=+1>(m,n)&nbsp;pair,&nbsp; generate 10 random instances.</font><font size=+1></font>
<p><font size=+1>If,&nbsp; after&nbsp; writing your code you find that
for some reson you want to run it on more datasets,&nbsp; that</font>
<br><font size=+1>would be fine;&nbsp; if you want to not run it on some
of the data sets you describe then,in your report,&nbsp; you will need
to explain why,&nbsp; e.g., you did not realize in advance the limitations
of the LP&nbsp;code that you would be using.</font>
<br><font size=+1></font>&nbsp;
<br><font size=+1></font>&nbsp;
<br><font size=+1></font>&nbsp;
</body>
</html>
